# 1.정렬 (Sorting)

정렬 알고리즘은 데이터를 특정한 기준에 따라 순서대로 나열한 것을 말한다. 프로그램에서 데이터를 가공할 떄 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해 사용하는 경우가 많아서 가장 많이 사용되는 알고리즘이다. 데이터를 정렬하면 이진탐색(Binary Search)이 가능하다.

## 1.1 선택정렬(Selection Sort)

선택 정렬은 가장 원시적인 방법으로 컴퓨터가 데이터를 정렬할때를 생각해보면된다. 데이터가 무작위로 여러가지 있을 때 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복하는것이다. 즉, **매번 가장 작은 것을 선택한다는 의미에서 선택정렬**이라고 한다.

![selectionsort](https://github.com/princenim/TIL/assets/59499600/1248efff-7404-4cc6-9351-a10f6e778a02)

1. 주어진 배열에서 가장 작은 값을 찾는다.
2. 찾은 가장 작은 값과 맨 첫번째 값으로 교체한다.
3. 교체한 첫번째 위치 원소 값을 제외한 값 중에서 가장 작은 값을 찾는다.
4. 두번째 원소와 찾은 가장 작은 값을 교체한다.
5. 반복한다.

### Java code

```java
public class SelectionSort {
    //오름차순
    public static void main(String[] args) {
        int[] arr = {3, 4, 6, 8, 7, 5, 0, 2, 1};

        for (int i = 0; i < arr.length; i++) {

            int minIdx = i; //최소값을 저장할 idx 처음에는 0으로 설정

            //한바퀴를 돌고 가장 작은 값을 찾은 후에 교체
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j; //작은 값 idx로 바꾸기 
                }

                //교체
                int tmp = arr[minIdx];
                arr[minIdx] = arr[i];
                arr[i] = tmp;
            }
        }
        System.out.print("Sorted Array :" + Arrays.toString(arr));
    }
}
```

### 선택정렬의 시간 복잡도

데이터의 개수가 N개 라고 했을 때,

- 첫번째 회전에서의 비교 횟수 : 1 ~ (N-1) ⇒ n-1
- 두번째 회전에서의 비교 횟수 : 2 ~ (N-1) ⇒ n-2

이므로 **(N-1) + (N-2) + … + 2 + 1 = n(n-1)/2** 이다.

따라서 시간복잡도는 **O(N^2**)이다. 이때 최선, 평균, 최악의 경우 모두 다 동일하다.

### 선택정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)** 이다.

### 선택정렬의 특징

1. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.
2. 비교 횟수는 많지만 실제로 교환하는 횟수는 적다. 따라서 교환이 많이 발생하는 자료상태라면 효율적이다.
3. 시간복잡도가 O(N^2)이므로 만약에 정렬해야 할 개수가 100배 늘어나면 수행시간은 10,000배로 늘어나기때문에 비효율적이다.
## 1.2 삽입정렬(Insertion Sort)

**삽입정렬은 특정한 데이터를 적절한 위치에 ‘삽입’한다는 의미에서 삽입정렬이다.** 따라서 삽입정렬은 선택정렬에 비해 구현 난이도가 높은 편이지만 선택 정렬에 비해 실행 시간측면에서 더 효율적이다. 삽입 정렬은 필요할 때만 위치를 바꾸므로 ‘데이터가 거의 정렬되어있을 때’ 훨씬 효율적이다. 선택 정렬은 현재데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸면 반면 삽입 정렬을 그렇지 않다.

그리고 삽입정렬은 두번째 데이터부터 시작한다. 왜냐하면 첫번쨰 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.

![isis](https://github.com/princenim/TIL/assets/59499600/ace9ec2c-9983-44bb-b080-1feff9aa75c8)

### 삽입정렬의 시간복잡도

최악의 경우(역으로 정렬되어 있을 경우) 선택 정렬과 마찬가지로 ,

첫번째 회전에서 1번, 두번째 회전에서 2번 +  … + (N-1)번 수행되므로

(N-1) + (N-2) + … + 2 + 1 = n(n-1)/2 이다. 즉, 시간복잡도는 O(N^2)이다.

하지만 원소가 이미 정렬되어 있는 경우 외부 루프를 N-1번을 도는 동안 비교 연산은 1번씩 수행되므로 최선의 경우 **O(N) = N** 이 된다.

### 삽입정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)** 이다.

### 삽입정렬의 특징

1. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.
2. 이미 정렬되어 있는 경우 매우 효율적이다.
3. 시간복잡도가 O(N^2)이므로 최악의 경우 일때, 만약에 정렬해야 할 개수가 100배 늘어나면 수행시간은 10,000배로 늘어나기때문에 비효율적이다.
