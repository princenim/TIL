# 1.정렬 (Sorting)

정렬 알고리즘은 데이터를 특정한 기준에 따라 순서대로 나열한 것을 말한다. 프로그램에서 데이터를 가공할 떄 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해 사용하는 경우가 많아서 가장 많이 사용되는 알고리즘이다. 데이터를 정렬하면 이진탐색(Binary Search)이 가능하다.

## 1.1 선택정렬(Selection Sort)

선택 정렬은 가장 원시적인 방법으로 컴퓨터가 데이터를 정렬할때를 생각해보면된다. 데이터가 무작위로 여러가지 있을 때 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복하는것이다. 즉, **매번 가장 작은 것을 선택한다는 의미에서 선택정렬**이라고 한다.

![selectionsort](https://github.com/princenim/TIL/assets/59499600/1248efff-7404-4cc6-9351-a10f6e778a02)

1. 주어진 배열에서 가장 작은 값을 찾는다.
2. 찾은 가장 작은 값과 맨 첫번째 값으로 교체한다.
3. 교체한 첫번째 위치 원소 값을 제외한 값 중에서 가장 작은 값을 찾는다.
4. 두번째 원소와 찾은 가장 작은 값을 교체한다.
5. 반복한다.

### Java code

```java
public class SelectionSort {
    //오름차순
    public static void main(String[] args) {
        int[] arr = {3, 4, 6, 8, 7, 5, 0, 2, 1};

        for (int i = 0; i < arr.length; i++) {

            int minIdx = i; //최소값을 저장할 idx 처음에는 0으로 설정

            //한바퀴를 돌고 가장 작은 값을 찾은 후에 교체
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j; //작은 값 idx로 바꾸기 
                }

                //교체
                int tmp = arr[minIdx];
                arr[minIdx] = arr[i];
                arr[i] = tmp;
            }
        }
        System.out.print("Sorted Array :" + Arrays.toString(arr));
    }
}
```

### 선택정렬의 시간 복잡도

데이터의 개수가 N개 라고 했을 때,

- 첫번째 회전에서의 비교 횟수 : 1 ~ (N-1) ⇒ n-1
- 두번째 회전에서의 비교 횟수 : 2 ~ (N-1) ⇒ n-2

이므로 **(N-1) + (N-2) + … + 2 + 1 = n(n-1)/2** 이다.

따라서 시간복잡도는 **O(N^2**) 이다. 이때 최선, 평균, 최악의 경우 모두 다 동일하다.

### 선택정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)** 이다.

### 선택정렬의 특징

1. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.
2. 비교 횟수는 많지만 실제로 교환하는 횟수는 적다. 따라서 교환이 많이 발생하는 자료상태라면 효율적이다.
3. 시간복잡도가 O(N^2)이므로 만약에 정렬해야 할 개수가 100배 늘어나면 수행시간은 10,000배로 늘어나기때문에 비효율적이다.
## 1.2 삽입정렬(Insertion Sort)

**삽입정렬은 특정한 데이터를 적절한 위치에 ‘삽입’한다는 의미에서 삽입정렬이다.** 따라서 삽입정렬은 선택정렬에 비해 구현 난이도가 높은 편이지만 선택 정렬에 비해 실행 시간측면에서 더 효율적이다. 삽입 정렬은 필요할 때만 위치를 바꾸므로 ‘데이터가 거의 정렬되어있을 때’ 훨씬 효율적이다. 선택 정렬은 현재데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸면 반면 삽입 정렬을 그렇지 않다.

그리고 삽입정렬은 두번째 데이터부터 시작한다. 왜냐하면 첫번쨰 데이터는 그 자체로 정렬되어 있다고 판단하기 때문이다.

![isis](https://github.com/princenim/TIL/assets/59499600/ace9ec2c-9983-44bb-b080-1feff9aa75c8)

### Java code

```java
public class SelectionSort {
    //오름차순
    public static void main(String[] args) {
        int[] arr = {3, 4, 6, 8, 7, 5, 0, 2, 1};

        for (int i = 0; i < arr.length; i++) {

            int minIdx = i; //최소값을 저장할 idx

            //한바퀴를 돌고 가장 작은 값을 찾은 후에 교체
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }

                //교체
                int tmp = arr[minIdx];
                arr[minIdx] = arr[i];
                arr[i] = tmp;
            }
        }
        System.out.print("Sorted Array :" + Arrays.toString(arr));
    }
}
```

### 삽입정렬의 시간복잡도

최악의 경우(역으로 정렬되어 있을 경우) 선택 정렬과 마찬가지로 ,
첫번째 회전에서 1번, 두번째 회전에서 2번 +  … + (N-1)번 수행되므로(N-1) + (N-2) + … + 2 + 1 = n(n-1)/2 이다. 즉, 시간복잡도는 **O(N^2)** 이다.

하지만 원소가 이미 정렬되어 있는 경우 외부 루프를 N-1번을 도는 동안 비교 연산은 1번씩 수행되므로 최선의 경우 **O(N) = N** 이 된다.

### 삽입정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)** 이다.

### 삽입정렬의 특징

1. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.
2. 이미 정렬되어 있는 경우 매우 효율적이다.
3. 시간복잡도가 O(N^2)이므로 최악의 경우 일때, 만약에 정렬해야 할 개수가 100배 늘어나면 수행시간은 10,000배로 늘어나기때문에 비효율적이다.


## 1.3 퀵 정렬(Quick Sort)

퀵 정렬은 이름처럼 가장 많이 사용되고 있는 빠른 정렬 알고리즘이다. 기**준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 정렬방법이다.**  퀵 정렬에는 **피벗(Pivot)** 이 사용되는데 이 피벗은 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 ’기준’을 말한다. 퀵정렬을 수행할때는 피벗을 어떻게 설정할지는 미리 명시해야하는데 가장 대표적인 분할 방식인 호어 분할(Hoare Partition)방식으로 설명하겠다.

(참고로 피봇을 정하는 기준에서 수행시간의 차이가 존재한다. )

호어 분할 방식에서는 리스트에서 첫 번째 데이터를 피벗으로 정한다. 따라서 피벗을 정한 뒤에 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾는다. 그리고 그 다음 데이터와 작은 데이터를 교환한다. 이러한 과정을 통해 정렬이 수행된다.

![qs](https://github.com/princenim/TIL/assets/59499600/72528a05-afb4-490b-81a4-f0511d91b2b1)

1. 리스트의 첫번째 원소인 ‘54’ 을 피벗으로 정한다.
2. 이제 피벗의 왼쪽부터 피벗인 ‘54’보다 큰 수 인 ‘93’을 선택하고, 오른쪽에서 피벗인 ‘54’ 보다 작은 수 ‘20’을 선택한다.
3. 그리고 93과 20을 교체한다.
4. 다시 피벗 ‘54’을 기준으로 피벗보다 큰 데이터와 작은 데이터를 각자 찾는다. 그리고 왼쪽부터 ‘54’보다 큰 수 ‘77’ 그리고 오른쪽부터 작은수 ‘44’를 찾아 교환한다.
5. 그리고 다시 피벗 ‘54’를 기준으로 큰수와 작은 수를 찾으면  왼쪽에서부터 찾은 큰값 ‘77’과 오른쪽에서부터 찾은 작은 값 ‘31’의 위치가 서로 엇갈린 것을 알 수있다.  이렇게 두 값이 엇갈린 경우에는 작은데이터 ‘31’과 피벗인 ‘54’을 서로 변경한다.
6. 교환하면 [ 31 26 20 17 44 **54** 77 55 93 ] 으로  교환한 수 ‘55’을 기준으로 왼 쪽은 ‘55’보다 작고, 오른쪽은 ‘55’보다 크다는 것을 알 수 있다 . 이렇게 피벗의 왼쪽에는 작은 데이터, 오른쪽에는 피벗보다 큰 데이터를 위치하도록 하는 작업을 **분할 혹은 파티션**이라고 한다.
7. 이제 ‘54’를 기준으로 왼쪽 리스트 [31 26 20 17 44 ] 에 31을 피벗을 다시 수행하고, 오른쪽 리스트 [77 55 93]에서 77로 피벗을 설정해 똑같이 다시 정렬을 반복하면 된다.
8. 이때 현재 리스트의 데이터 개수가 1개인 경우일때 정렬이 종료된다.

### Java Code

```java
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {5,7,9,0,3,1,6,2,4,8};

        quickSort(arr, 0, arr.length - 1);
        System.out.print("Sorted Array :" + Arrays.toString(arr));
    }
    
    public static void quickSort(int[] arr, int start, int end) {
        
        System.out.println(Arrays.toString(arr));
        //start가 end보다 크거나 같다면 정렬할 원소가 1개 이하이므로 정렬 하지않고 종료
        if (start >= end) {
            return;
        }

        //모두 인덱스로 사용할 것
        int pivot = start; //피벗은 첫번째 원소
        int left = start + 1;
        int right = end;

        while (left <= right) {
            //피벗보다 큰 데이터를 찾을 때까지 반복 즉, 큰 수를 발견하면 멈춤
            while (left <= end && arr[left] <= arr[pivot]) { //피봇이 커야지 while문 동작
                left += 1;
            }
            //피벗보다 작은 데이터를 찾을 때까지 반복
            while (right > start && arr[right] >= arr[pivot]) {
                right -= 1;
            }

            //엇갈렸다면 작은 데이터와 피봇을 교체
            if (left > right) {
                swap(arr, right, pivot); //right이 작은 데이터
            } else {
                //엇갈리지 않았다면 작은 데이터와 큰 데이터 교체
                swap(arr, left, right);
            }
        }

        //분할 이후 왼쪽과 오른쪽 부분에서 각각 정렬 수행
        quickSort(arr, start, right - 1);
        quickSort(arr, right + 1, end);
    }

    public static void swap(int[] arr, int i, int j) {
        int tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
    }
}
```

참고로 [6,9,7,8]일때 6이 피봇이고 6보다 왼쪽부터 6보다 큰수는 9로 존재하지만 작은 수는 존재하지 않는다. 이때는 아무런 교체가 일어나지 않는다. 코드상에서는 피봇 6과 right 이 6으로 같은 수가 교체가된다.

또한 [9,8,7]의 경우 9보다 큰 수가 존재하지 않으나 작은수 7이 존재한다. 이때는 피봇 9과 작은수 7이 교체된다.

### 퀵 정렬의 시간복잡도

먼저 퀵소트는 시간복잡도가 최악, 최선의 경우가 다르다.  병합정렬처럼 정확히 반으로 나누어 정렬을 진행하지 않기때문에 최악의 경우가 존재한다.  최선의 경우 시간 복잡도는 **O(N logN)** 이며, 최악의 시간복잡도는 선택정렬과 삽입정렬과 마찬가지로 **O(N^2)** 이다.

<img width="772" alt="im" src="https://github.com/princenim/TIL/assets/59499600/8c32c8c3-e9b5-4dc8-bd18-d331bd5e7b4a">


1 ) **최선의 시간복잡도**

항상 절반으로 분할될 때 최선의 시간복잡도를 가진다. 항상 절반으로 분할되어 총 길이가 1이 되되려면 총 logN번 분할하게 된다. 예를들어 만약 데이터의 개수가 8개일 경우, 중간 값이 피벗으로 선택되면 8개 → 4개, →2개 → 1개 순으로 3번에 걸쳐 데이터가 분할된다. 이는 N개의 데이터가 1개로 분할되기까지를 logN (log8 = 3)으로 표현 할 수 있다.  따라서 분할의 횟수는 logN이며 , 분할될때마다 n번의 비교 연산이 이루어지므로 최선의 경우 시간복잡도는 **O(N logN)** 이다.

2 ) **최악의 시간 복잡도**

먼저 오름차순이나 내림차순으로 이미 정렬되어 있을 때  피벗을 최솟값 혹은 최대박으로 정했을 때 최악의 시간 복잡도를 가진다. 예를들어 1,2,3,4 라는 배열이 존재하고 피벗을 1이라고 가정한다면 1은 고정이고, [2,3,4]를 정렬해야한다. 또 피벗이 2가 되고 [3,4]를 정렬해야한다.  이 경우에는 각 배열의 비교 연산 횟수가 평균 N번 발생한다. 하지만 재귀호출은 배열의 원소 수만큼 발생하므로 재귀호출의 횟수는 N으로 늘어나 N * N 최악의 경우 **O(N^2)** 의 시간복잡도를 가지게 된다.

### 퀵 정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)** 이다.

### 퀵 정렬의 특징

1. 평균적으로 가장 빠른 정렬 알고리즘이다.
2. 이미 데이터가 정렬되어 있는 경우 시간복잡도 O(N^2)로 매우 느리게 동작한다.  삽입정렬은 이미 데이터가 정렬되어 있는 경우 O(N)으로 빠르게 동작되는 것과 반대된다.
3. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.