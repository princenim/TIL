# 1.정렬 (Sorting)

정렬 알고리즘은 데이터를 특정한 기준에 따라 순서대로 나열한 것을 말한다. 프로그램에서 데이터를 가공할 떄 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해 사용하는 경우가 많아서 가장 많이 사용되는 알고리즘이다. 데이터를 정렬하면 이진탐색(Binary Search)이 가능하다.

## 1.1 선택정렬(Selection Sort)

선택 정렬은 가장 원시적인 방법으로 컴퓨터가 데이터를 정렬할때를 생각해보면된다. 데이터가 무작위로 여러가지 있을 때 데이터 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두번째 데이터와 바꾸는 과정을 반복하는것이다. 즉, **매번 가장 작은 것을 선택한다는 의미에서 선택정렬**이라고 한다.

![selectionsort](https://github.com/princenim/TIL/assets/59499600/1248efff-7404-4cc6-9351-a10f6e778a02)

1. 주어진 배열에서 가장 작은 값을 찾는다.
2. 찾은 가장 작은 값과 맨 첫번째 값으로 교체한다.
3. 교체한 첫번째 위치 원소 값을 제외한 값 중에서 가장 작은 값을 찾는다.
4. 두번째 원소와 찾은 가장 작은 값을 교체한다.
5. 반복한다.

### Java code

```java
public class SelectionSort {
    //오름차순
    public static void main(String[] args) {
        int[] arr = {3, 4, 6, 8, 7, 5, 0, 2, 1};

        for (int i = 0; i < arr.length; i++) {

            int minIdx = i; //최소값을 저장할 idx

            //한바퀴를 돌고 가장 작은 값을 찾은 후에 교체
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[j] < arr[minIdx]) {
                    minIdx = j;
                }

                //교체
                int tmp = arr[minIdx];
                arr[minIdx] = arr[i];
                arr[i] = tmp;
            }
        }
        System.out.print("Sorted Array :" + Arrays.toString(arr));
    }
}
```

### 선택정렬의 시간 복잡도

데이터의 개수가 N개 라고 했을 때,

- 첫번째 회전에서의 비교 횟수 : 1 ~ (N-1) ⇒ n-1
- 두번째 회전에서의 비교 횟수 : 2 ~ (N-1) ⇒ n-2

이므로 **(N-1) + (N-2) + … + 2 + 1 = n(n-1)/2** 이다.

따라서 시간복잡도는 **O(N^2**)이다. 이때 최선, 평균, 최악의 경우 모두 다 동일하다.

### 선택정렬의 공간복잡도

주어진 배열 안에서 교환을 하므로 **O(N)**이다.

### 선택정렬의 특징

1. 제자리 정렬 알고리즘(in-place sorting)의 하나로 배열이외의 다른 추가 메모리를 요구하지 않는다.
2. 비교 횟수는 많지만 실제로 교환하는 횟수는 적다. 따라서 교환이 많이 발생하는 자료상태라면 효율적이다.
3. 시간복잡도가 O(N^2)이므로 만약에 정렬해야 할 개수가 100배 늘어나면 수행시간은 10,000배로 늘어나기때문에 비효율적이다.