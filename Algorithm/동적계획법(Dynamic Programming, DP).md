# 1. 동적계획법(Dynamic Programming, DP)

`동적계획법`은 기본적인 아이디어 하나로 큰 문제를 여러개의 작은 문제로 나누어 그 결과를 저장해 다시 큰 문제를 해결할때 사용하는 것을 말한다. 특정한 알고리즘이 아닌 하나의 문제해결 패러타임이라고 볼수 있다.

가장 대표적인 예는 피보나치 수열이 있다. 해당 내용은 밑의 글에서 확인 가능하다.

- [재귀 알고리즘과 피보나치 수열](https://github.com/princenim/TIL/blob/master/Algorithm/%EC%9E%AC%EA%B7%80%20%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EA%B3%BC%20%ED%94%BC%EB%B3%B4%EB%82%98%EC%B9%98%20%EC%88%98%EC%97%B4.md)

위 글을 보면 피보나치 수열을 재귀와 메모이제이션을 이용해 구현했다.  `메모이제이션(memoization)은` 동적계획법 즉 동적 프로그래밍 방법 중 하나로 재귀처럼 동일한 계산을 반복할때 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복수행을 제거해 프로그램의 실행속도를 올려준다. 값을 저장하는 방법이므로 캐싱이라고도 한다.

### 분할정복**(Divide and Conquer Algorithm)**과의 차이점

`분할정복(Divide and Conquer Algorithm)`은 문제를 나눌 수 없을 때까지 나누어서 각각을 풀면서 다시 합병해 답을 얻는 알고리즘이다. `Top-Down (하향식)` 접근법으로 상위의 해답을 구하기위해 아래로 내려가면서 하위의 해답을 구하는 방식이다.

`**분할정복과` `DP`는 문제를 잘게 쪼개서 가장 작은 단위로 분할한다는 공통점**이 있지만 `DP`는 부분 문제는 중복되어 상위 문제 해결 시 재활용한다는 점 즉 `메모이제이션을` 사용할 수 있으나  분할 정복은 부분 문제는 서로 중복되지 않아 `메모이제이션` 기법을 사용하지 않는다는 특징이 있다.

# 2. DP의 사용 조건

DP가 문제에 적용되려면 2가지 조건을 만족해야한다. `Overlapping Subproblem(겹치는 부분 문제)`와 `Optional Substructure(최적 부분 구조)`이다.

### Overlapping Subproblem(중복되는 반복 문제)

`DP`는 기본적으로 문제를 작은 문제로 나누고 그 작은 문제의 결과 값을 재활용해서 큰 문제의 답을 구한다. 즉,  동일한 작은 문제들이 반복해서 해결할 수 있어야한다.

### Optional Substructure(최적 부분 구조)

큰 문제의 최적해가 작은 문제의 최적해로부터 구해질 수 있어야한다.

# 3. DP의 구현 방법

`DP`를 구현하는 방법에는 2가지가 존재한다. `Top-Down` 과 `Bottom up` 이다.

### Top-Down(하향식)

분할 정복과 비슷한 구조를 갖고 있다. 큰 문제를 해결하기 위해 작은 문제를 **재귀적으로 해결하는 방법**으로 재귀 함수를 사용한다. 이때하지만 이 방법은 가독성은 높지만 재귀 함수를 사용하면서 함수 호출 스택의 크기가 커져 스택 오버플로우가 발생할 가능성이 존재한다.

### Bottom up(상향식)

큰 문제를 작은 문제들로 쪼개어 작은 문제부터 해결해 나가는 방식으로 이전의 작은 문제의 결과를 재활용해 큰 문제를 해결한다. 이때 작은 문제의 결과를 저장하는 배열 또는 리스트 등의 자료구조가 필요로한다. 따라서 입력 크기가 커질수록 더 많은 메모리를 필요로 하지만 계산을 수행하면서 재귀함수를 호출하지 않으므로 호출 스택과 관련한 문제를 방지할 수 있다. **보통 for문을 이용해 구현한다.**

# 4. DP 사용하기

1. **DP로 풀 수 있는 문제인지 확인**

즉,  DP는 알고리즘이 아니라 하나의 방법론이다. 따라서 이 문제를 풀기위해서는 당연히 해당 문제가 DP 유형임을 정확히 알아야한다. 특정한 문제를 완전 탐색 알고리즘으로 접근했을 때 시간이 매우 오래 걸리면 DP 를 적용할 수 있는지 즉 **큰** **문제의 부문 문제들의 중복 여부를 확인해보자.**

2. **문제의 변수 파악**

DP는 현재 변수에 따라 그 결과값을 찾고 그것을 전달해 재사용한다. 즉 문제 안의 변수의 개수를 찾아야한다. 예를 들어 피보나치 수열에서는 n번째 숫자를 구해야하므로 n이 변수가 된다.

3. **변수 간 관계식 만들기**

변수들에 의해 결과 값이 달라질 수 있지만 동일한 변수값인 경우 결과는 동일하다. 따라서 그 관계식을 만들수 있어야한다. 이 식을 `점화식` 이라고 하며 이 점화식을 통해 짧은 코드에서 반복/재귀를 이용해 해결될수 있도록 만들어야한다. 예를 들어 피보나치 수열에서는 `f(n)=f(n-1)+ f(n-2)` 이다.

4. **메모하기**

위의 점화식의 결과를 저장할 수 있어야한다. 즉 메모이제이션을 말한다. 변수값에 따른 저장할 배열, 리스트 등을 만들고 그 값을 배열 내에 저장하고 재사용 할 수 있어야한다.

5. **기저 상태 파악하기**

가장 작은 문제의 상태를 알아야한다. 피보나치 수열은 `f(0)=0`  ,`f(1)=1`  이다. 해당 기저 상태를 파악해 미리 배열에 저장하면 된다.

6. **구현하기**

위에 설명한 `Top-Down` , `Bottom-up` 을 활용해 DP를 구현하면 된다.