# 1.변수(variable)

## 1.1 변수(variable)란?

프로그래밍 언어에서 변수란, **단 하나의 값을 저장할 수 있는 메모리상의 공간**을 의미한다.

## 1.2 변수의 선언와 초기화

```java
//age라는 이름의 변수 선언
int age // 변수타입 변수이름
```

`변수타입`은 변수에 저장될 값이 어떤 타입인지를 지정하는 것이다. 자바는 정수형, 실수형, 문자형 등이 있다.

`변수이름`은 말 그대로 변수에 붙인 이름이다. 변수는 값을 저장할 수 있는 메모리 공간이므로 변수의 이름은 메모리 공간에 이름을 붙여주는 것이다. 그래야 이름을 이용해 저장공간(변수)에 값을 저장하고 , 저장된 값을 읽어오기도 할 수 있는 것이다.

### 변수의 초기화

변수를 선언한 이후부터는 변수를 사용할 수 있으나 그 전에 반드시 변수를 초기화(Initiallization)해야 한다. 여러 프로그램이 공유하는 자원이므로 전에 다른 프로그램에 의해 저장된 알수없는 값 (= garbage value)가 남아있을 수 있기 때문이다. 즉 변수의 초기화란 변수를 사용하기 전에 처음으로 값을 저장하는 것이다.

```java
int age= 15; //변수 age를 선언하고 25호 초기화한다. 
```

## 1.3 변수의 명명규칙

‘변수의 이름’처럼 프로그래밍에서 사용하는 모든 이름을 ‘식별자(identifier )’이라고 하며, 식별자는 같은 영역 내에서 서로 구분될 수 있어야한다.

- 대소문자가 구분되며 길이에 제한이 없다
    - True와 true는 서로 다른 것으로 간주된다.
- 예약어를 사용해서는 안 된다. 예약어는 키워드 또는 reserved word라고 하는데 프로그래밍 언어의 구문에 사용되는 단어를 뜻한다.
    - e.g. acstract, assert, byte, do 등
- 숫자로 시작해서는 안 된다.
- 특수문자는 `_` 과 `$`만 허용한다.

이 외에 권장하는 규칙들이 존재한다.

- 클래스 이름의 첫 글자는 항상 대문자로 한다
    - 변수와 메서드의 이름의 첫 글자는 항상 소문자로 한다
- 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다
    - e.g. lastIndexOf, StringBuffer
- 상수의 이름은 모두 대문자로 한다. 여러 단어로 이루어진 경우는 `_` 로 구분한다.
    - e.g. PI, MAX_NUMBER

# 2. 변수의 타입

우리가 주로 사용하는 값(data)의 종류는 문자와 숫자로 나눌 수 있으며, 숫자는 다시 정수와 실수로 나눌 수 있다.

이러한 값(data)의 종류에 따라 값이 저장될 공간의 크기와 저장형식을 정의한 것이 자료형이다.

### 기본형과 참조형

자바의 자료형에는 기본형과 참조형이 있다.

- `기본형 변수`는 실제 값(data)을 저장한다.
    - 기본형 자료형에는 논리형(boolean), 문자형(char), 정수형(byte, short, int, long), 실수형(float, double)
- `참조형 변수`는 어떤 값이 저장되어 있는 주소 (memory address)를 저장한다.
    - 8개의 기본형을 제외한 모든 나머지 타입이 참조변수

    ```java
    //Date 객체를 생성하는 new 연산자를 통해 생성된 객체 주소를 today에 저장
    Date today = new Date(); 
    ```


## 2.1 기본형(Primitive Type)

자바의 기본형은 8가지 타입이 있다.

![a](https://github.com/princenim/TIL/assets/59499600/5b335761-9c2d-47d6-9d34-1c7e30708c07)



문자형인 char은 내부적으로 정수로 저장하기 때문에 정수형과 별반 다르지 않으며, 정수형 또는 실수형과 연산이 가능하다. 반면에 boolean은 다른 기본형과의 연산이 불가능하다. 즉 boolen을 제외한 나머지 7개의 기본형은 서로 연산과 변환이 가능하다.

각 자료형이 가질 수있는 값의 범위를 정확히 외울 필요는 없고, 정수형(byte, short, int, long) 의 경우 -`2^(n-1) ~ 2^(n-1) -1` 이라고 생각하면된다. 여기서 n은 bit의 수를 말한다.  예를들어 int의 경우 4byte = 32bit이므로 `-2^31 ~ 2^31 -1` 의 범위를 갖는다. 따라서 int 타입의 변수는 대략 10자리 수 값을 저장할 수 있다. 7~ 9 자리의 숫자를 계산할때는 넉넉히 long 타입 (약 19자리) 변수를 선언하는 것이 좋다. 연산중에 저장범위를 넘으면 원하지 않는 값을 결과로 얻게 될수 있기 때문이다.  (`= 정수 오버플로우`)

실수형은 정수형과 저장형식이 달라서 같은 크기라도 훨씬 큰 값을 표현할 수 있으나 오차가 발생할 수 있다는 단점이 있다. 그래서 정밀도(precision)이 중요한데, 정밀도가 높을수록 발생할 수 있는 오차의 범위가 줄어든다. float형은 정밀도가 7자리로 10진수로 7자리의 수를 오차없이 저장할수 있다는 뜻이다. , double은 정밀도가 15자리로 double이 정밀도가 더 높다.

## 상수와 리터럴

상수(constant)는 ‘값을 저장할 수 있는 공간’이지만 , 변수와 달리 한번 값을 저장하면 다른 값으로 변경할 수 없다. 변수의 타입 앞에 키워드 `final` 만 붙이면 된다. 반드시 선언과 동시에 초기화해야하며 그 후에는 값을 변경할 수 없다. 이름은 모두 대문자로 하는 것이 관례이며, 여러단어의 경우 `_`로 구분한다.

(JDK 1.6 부터 동시에 초기화하지 않아도 사용전에만 초기화해도 가능하다.)

```java
final int MAX_SPEED = 10; //상수를 선언 및 초기화 
```

### 리터럴(literal)

프로그래밍에서 상수를 ‘값을 한번 저장하면 변경할 수 없는 저장공간’ 으로 정의했기때문에, 이와 구분하기 위해 리터럴이러는 용어를 만들었다.

- 변수 : 하나의 값을 저장하기 위한 공간
- 상수 : 값을 한번만 저장할 수 있는 공간
- 리터럴 : 그 자체로 값을 의미하는것

```java
int year = 2014; // year이 변수 2014가 리터럴
final int MAX_VALUE = 100; //MAX_VALUE 가 상수, 100이 리터럴
```

### 리터럴의 타입과 접미사

리터럴에서 타입이 있다. 변수의 타입은 저장될 리터럴의 타입(값의 타입)에 의해 결정된다.

![d](https://github.com/princenim/TIL/assets/59499600/08686367-3fc1-461a-8fea-251effa7651c)

정수형의 경우 long타입에 접미사 `l` 또는 `L` 을 붙이고, 접미사가 없으면 int 타입의 리터럴이다.

byte와 short 타입의 리터럴은 별도로 존재하지 않는다.

10진수 외에도 16진수라는 것을 표한하기 위해 접두사 `0X`, 8진수의 경우 `0`을 붙인며, 2진수의 경우 `0b` 라고 붙인다.

```java
int octNum  = 010; //8진수 10, 2진수 8
int hexNum = 0x10; // 16진수 10, 10진수 16
int binNum = 0b10; // 2진수 10, 10진수 2

float pu = 3.14F;
double rate = 1.618; //d 생략함

long big = 100_000_00_00L;
```

실수형의 경우 float 타입의 리터럴에 접미사 `f` , `F`를 붙이고, double타입의 리터럴에는 d , D를 붙이나 실수형의 기본 자료형이 double이기 때문에 생략가능하다.  또한 리터럴에 `소수점`이나 10의 제곱을 나타내는 기호 `E`,`e` 그리고 접미사 `F`, `f`, `d`, `D` 를 포함하면 모두 실수형 리터럴이다.

JDK 1.7부터 정수형 리터럴의 중간에 구분자 `_`를 넣을 수 있어 큰숫자를 편하게 읽을 수 있다.

### 타입의 불일치

리터럴의 타입은 저장될 변수의 타입과 일치하는 것이 보통이지만, 타입이 달라도 저장범위가 넓은 타입에 좁은 타입의 값을 저장하는 것은 허용된다.

그러나 리터럴의 타입이 변수의 타입보다 저장범위가 넓으면 컴파일 에러가 발생한다.

```java
int i  = 'A'; // 문자 'A'의 유니코드인 65가 변수 i에 저장된다. 4byte > 2byte (char) 
long l = 123; // int보다 long타입이 더 범위가 넓다.   8byte > 4byte
double d = 3.14f; //float보다 double이 더 범위가 넒다. 8byte > 4byte

//컴파일 에러 
int i = 0x123456789; //int타입의 범위를 넘음
float f = 3.14; // 리터럴이 double형임
```

byte와 short 는 따로 리터럴이 존재하지 않으므로 int 리터럴을 사용한다. 단 shot타입의 변수가 저장할 수 있는 범위에 속한 것이어야 한다.

```java
byte b = 65; //byte타입 ~128 ~ 127에 저장 가능한 범위의 int타입 리터럴  
short s = 0x1234;
```

### 문자 리터럴과 문자열 리터럴

‘A’ 와같이 작은따옴표로 문자 하나를 감싼 것을 `문자 리터럴`, 두 문자 이상은 큰 따옴표로 감싸야하며 `문자열 리터럴`이라고 한다.   문자열 리터럴은 안에 아무런 문자를 넣지 않아도 괜찮으며 이를 빈 문자열 이라고 하지만 , 문자 리터럴은 반드시 안에 하나의 문자가 있어야한다.

원래 String은 클래스이므로 아래와 같이 객체를 생성하는 연산자 (new) 를 사용해야 하지만 특별히 제외해도  괜찮다.

```java
char ch = 'C';
String name = "java";
```

그리고 덧셈 연사를 이용해 문자열끼리 결합할 수 있다. 피연산자 중 어느 한쪽이 String이면 나머지 한쪽을 먼저 String 으로 변환한 다음 두 String을 결합한다. 기본형과 참조형의 구분없이 어떤 타입의 변수도 문자열과 덧셈연산을 수행하면 그 결과가 문자열이 된다.

## 2.3 형식회된 출력 printf()

printf는 지시자를 통해 변수의 값을 여러가지 형식으로 변환해 출력해준다.  println()은 불가능하다. `%n`는 줄바꿈을 말한다.

![c](https://github.com/princenim/TIL/assets/59499600/eae43b80-6506-4b27-b4ad-d0713d267cdd)

```java
System.out.printf("age : %d", age);
System.out.printf("age : %d", 14);

boolean hi = true;
System.out.printf("BOOL=%b%n",hi);

//정수 출력시 출력될 값이 차지할 공간을 숫자로 지정가능
//5는 출력형식이 차지할 자리의 수를 -는 왼쪽정렬. 그리고 0이 존재하는 경우 나머지 부분을 0으로 채운다.
int finger = 8;
System.out.printf("finger=[%5d]%n",finger); //finger=[    8]
System.out.printf("finger=[%-5d]%n",finger); //finger=[8    ]
System.out.printf("finger=[%05d]%n",finger); //finger=[00008]

//#를 사용하면 접두사 0x와 0이 각각 붙는다. 
long hex= 0xFFFF_FFFF_FFFF_FFFFL;
System.out.printf("hex= %x%n", hex);  //hex= ffffffffffffffff
System.out.printf("hex= %#x%n", hex); //hex= 0xffffffffffffffff
System.out.printf("hex= %#X%n", hex); //hex= 0XFFFFFFFFFFFFFFFF대문자, %X는 대문자로 출력

//%전체자리.소수점아래자리f
double d = 1.12345678;
System.out.printf("d=%14.10f%n", d); //전체 14자리 중 소수점 아래자리 10자리

//문자열도 가능
String url = "www.hello.world";
System.out.printf("[%s]%n", url);
System.out.printf("[%20s]%n", url); //최소 20글자 출력공간 확보. 우측정렬 , [     www.hello.world]
System.out.printf("[%-20s]%n", url); //최소 20글자 출력공간 확보. 좌측정렬 , [www.hello.world     ]
System.out.printf("[%.8s]%n", url); //왼쪽에서 8글자만 출력 , [www.hell]
```

실수형 값에 출력에 사용되는 지시자는 %f가 주로 쓰이고, %e는 지수를 형태로 출력할때, %g는 값을 간략하게 표현할 떄 사용한다.

그리고 %f는 소수점 아래 6자리까지만 출력하기 때문에 소수점 아래 7자리에서 반올림한다. 그리고 전체 자리수와 소수점 아래의 자리수를 지정할 수도 있다. 소수점 아래의 빈자리는 0으로 채우고 정수의 빈자리는 공백으로 채워서 전체 자리수를 맞춘다. 즉 `%전체자리.소수점아래자리f` 이다.

지시자 %s에도 숫자를 추가하면 원하는 만큼의 출력공간을 확보하거나 문자열의 일부만 출력할 수 있다.


# 3. 진법
## 3.1 2진법과 10진법

컴퓨터는 2진 체계로 설계되어 있다. 따라서 0과 1밖에 모르기 때문에 모든 수를 2진수로 바꾸어 저장한다.

```java
int age = 25 // 25라는 10진수를 11001이라는 2진수로 변환해 저장
```

이처럼 2진법은 0과 1로만 데이터를 표현하기 때문에 10진법에 비해 많은 자리수를 필요로 한다.

## 3.2 비트와 바이트

한 자리의 2진수를 `비트(bit, binary digit)`라고 하며, 1비트는 컴퓨터가 값을 저장할 수 있는 최소단위이다. 하지만 1비트는 너무 작은 단위이기떄문에 1비트 8개를 묶어서 `바이트(byte)`라는 단위로 정의해서 데이터의 기본단위로 사용한다

이 외에도 `워드(word)`가 있는데 이는 CPU가 한번에 처리할 수 있는 데이터의 크리를 말하며, 32비트 CPU에서 1워드는 32비트 이고, 64 비트 CPU에서 1워드는 64비트이다.

1비트로 2^1 = 2개, 2비트로는 2^2 = 4개, 2^3 = 8개, 4비트로는 2^4 = 16개의 값을 표현할수있다. 따라서 n비트로 `2^n` 개의 값을 표현할 수 있다. 그리고 n비트로 10진수를 표현한다면 표현가능한 10진수의 범위는 `0 ~ 2 ^n -1` 이다. (0부터 시작해야하기때문에)  즉 정리하면,

- n 비트로 표현할 수 있는 10진수
  - 값의 개수 = 2^n
  - 값의 범위 = 0 ~ 2^n -1

## 3.3 8진법과 16진법

2진법으로 값을 표현하면 자리수가 길어지는 단점이 있는데 이를 보완하기 위해 8진법, 16진법을 사용한다. 2진수를 8진수로 변환하려면 2진수를 뒤에서부터 3자리씩 끊어서 그에 해당하는 8진수로 바꾸면 되고, 16진수 역시 4자리씩 끊어서 변환하면 된다.

## 3.6 음수의 2진 표현 - 2의 보수법

n비트의 2진수로 표현할 수 있는 값의 개수는 모두 2^n 개 이므로, 4비트의 2진수로는 모두 2^4= 16개의 값을 표현할 수 있다. 즉 0 ~ 15 까지의 정수를 나타낼 수 있다.

하지만 정수가 아닌 음수를 표현하려면 어떻게 해야할까?

만약에 가장왼쪽의 첫번째 비트를 부호에 사용하면 0일때 양수, 1일떄 음수로 맨 왼쪽의 비트에 따라 부호를 알수 있다. 하지만 이 방법은 두수를 더했을때 2진수로 0이 되지않고, 0이 2개 존재, 그리고 두 값을 더할때 음수부호가 있다면 컴퓨터가 계산하기 어렵다. 따라서 등장한 방법이 2의 보수법이다.

### 2의 보수법

어떤 수의 ‘n의 보수’는 더했을 때 n이 되는 수를 말한다. 즉 10진법에서 7의 10의보수는 3이며, 3의 10의 보수는 7이다. 그래서 3과 7은 10의 보수의 관계에 있다고 표현한다. 그렇다면 2의 보수 관계에서는 더해서 2가 되는 두 수의 관계를 말하며, 10진법의 2는 2진법에서는 ‘10’이다. 그리고 2진수 ‘10’은 자리올림이 발생하고 0이 되는 수를 뜻한다. 결국 **2의 보수관계에서는 두 2진수를 더하면 자리올림이 발생하고 0이 되어야한다.**

```java
  0 1 0 1 <- 10진수로 5
+ 1 0 1 1 <- 10진수로 -5
---------------
1 0 0 0 0  <- 자리올림이 발생했으나 크기가 4비트라서 버려짐
```

예시에서 2진수 ‘’0101,’1011’은 서로 2의 보수관계에 있으며 두 2진수(어떤수와 어떤수의 보수)를 더하면 0이 된다.  **이처럼 두 2진수로 절대값이 같고, 부호가 다른 두 10진수를 표현하는 것을 2의 보수법이라고한다.**

### 음수를 2진수로 표현하기

1) 음수의 절대값을 2진수로 변환한다.

2) 1)에서 구한 2진수의 1을 0으로, 0을 1로 변환한다 (= 1의 보수 구하기)

3) 2)의 결과에 1을 더한다. (2의 보수 구하는 방법 : 1의 보수 + 1)

위의 방법대로 -5를 2진수로 표현하면

```java
-5 -> 5 -> 0101 -> 1011 
```

더 자세히 설명하면, 먼저 -5의 절대값 5의 2진수 ‘0101’를 구한다. 그리고 이제 ‘0101’의 2의 보수를 구하면 되는데. 이때  1의 보수 구하는 방법으로 ‘1010’으로 변환한다 . 그리고 1의 더해서 2의 보수를 구하면 된다. 따라서 ‘1011’ 을 구할 수 있다.

# 4. 기본형
## 4.1 논리형 - boolean

논리형에는 boolean 한가지 밖에 없다. true, false로 하나만 저장할 수 있으면 디폴트는 false이다.
자바에서는 데이터를 다루는 최소단위가 byte이기 때문에 boolean의 크기는 1byte이다. (8bit =1byte)
자바에서는 대소문자가 구별되기 때문에 True와 true는 다른것으로 간주된다.

## 4.2 문자형 - char

문자형도 char 한가지 밖에 없다. 또한 char 타입의 변수는 단하나의 문자만을 저장할 수 있다.

```java
//문자 'A'를 char 타입 변수에 저장 
char ch = 'A'; 

//int타입으로 변환해 유니코드 확인
int n = (int)ch;
```

코드를 보면 변수에 ‘문자’가 저장된 것 같지만 사실은 문자가 아닌 ‘문자의 유니코드(정수)’가 저장된다. 컴퓨터는 숫자밖에 모르기때문에 모든 데이터를 숫자로 변환해 저장한다.
문자 ‘A’의 유니코드는 65기 때문에 변수에는 65가 저장된다. 따라서 문자의 유니코드를 알고 싶으면 char형 변수에 저장된 값을 정수형(int)로 변환하면 된다.

### 특수문자다루기

영문자 이외에 tab이나 backspace 등의 특수문자를 저장하는 방법이 존재한다.

| tab | \t |
| --- | --- |
| backspace | \b (백스페이스 삽입 또는 뒤에 문자 제거 ) |
| form feed | \f |
| new line | \n |
| carriage return | \r |
| 역슬래쉬 | \\ |
| 작은따옴표 | \’ |
| 큰따옴표 | \” |
| 유니코드(16진수)문자  | \u유니코드 e.f. char a=’\0041’ |

### char타입의 표현형식

char 타입의 크기는 2byte(16bit)이므로 , 16자리의 2진수로 표현할 수 있는 정수의 개수는 2^16인 65536개이다. 따라서 char형 변수는 이 범위 내의 유니코드 중 하나를 저장할 수 있다. 예를들어 문자 ‘A’를 저장하면 아래와 같이 2진수  0000000001000001로 저장된다. (유니코드는 10진수로 65) 따라서 실제로 변수에는 문자가 아닌 문자의 유니코드(정수) 저장되며 표현형식 역시 정수형과 동일하다.

다만 정수형과 달리 char은 음수를 나타낼 필요가 없으므로 char타입에 저장되는 값인 유니코드는 모두 2^6인 65536개이며 범위는 0 ~ 65535개 이다. 반면에 정수형인 short의 타입은 char형과 같은 2byte인데 절반을 음수표현에 사용하므로 -32768 ~ 32767을 범위로 갖는다.

- 2byte  = 16비트로 표현할 수 있는 정수의 개수는 2^16
  - short 타입의 표현범위 : -2^15 ~ 2^15 -1 (-32768 ~ 32767)
  - char 타입의 표현범위 : 0 ~ 2^16 -1 (0~ 65536)

```java

char ch = 'A'; //유니코드 65 
short s = 65;
```

다음과 같이 변수에 값을 저장하면 둘다 컴퓨터에 2진수로 똑같은 값이 저장된다. 그런데 변수를 출력하면 다르게 값이 나오는데 이는 `println()` 이 변수의 타입에 맞게 출력했기 때문이다. 따라서 값은 어떻게 해석하느냐에 따라 결과가 달라진다.

### 인코딩과 디코딩

- 인코딩(encoding) : 문자를 코드로 변환
  - ‘A’ → 65
- 디코딩(decoding) : 코드를 문자로 변환
  - 65 → ‘A’

### 아스키 코드(ASCII)와 유니코드(Unicode)

![AA](https://github.com/princenim/TIL/assets/59499600/d0c7df5f-7b4c-4971-9a9e-370091e1a6d0)

**아스키코드**는 ‘American Standart Code for Information Interchange’의 약자로 정보교환을 위한 미국 표준 코드를 말한다. 2^7의 문자집합(character set)으로 제공하는 7bit 부호로 기호와 숫가, 영대소문자로 구성되어있다. 숫자 0~ 9, 대문자 A~Z, 소문자 a~z가 연속적으로 배치되어 있다는 특징이 있다 .
**유니코드**는 전 세계의 모든 문자를 하나의 통일된 문자집합으로 표현하기 위해 등장하였다. 처음에 문자를 2byte로 표현하려 했으나 부족해서 21bit(약200만 문자)로 확장되었다.

유니코드 포함할 문자들의 집합을 정의했는데, 이것을 유니코드 캐릭터 셋(character set) 이라고 한다.  그리고 이 문자 셋에 번호를 붙인 것이 유니코드 인코딩이다. 유니코드 인코딩에는 UTF_8, UTF16, UTF-32 가 있는데 자바에서는 UTF-16을 사용한다. 그리고 이 UTF-16은 모든 문자를 2byte의 고정크기로 표현하고 UTF-8은 하나의 문자를 1~ 4byte의 가변크기로 표현한다.
이 두 인코딩 모두 처음 128문자가 아스키와 동일하다. 
모든 문자의 크기가 동일한 UTF-16이 문자를 다루기는 편리하지만, 1byte로 표현할 수있는 영어와 숫자가 2byte로 표현되므로 문서의 크기가 커진다. 반대로 UTF-8은 영문과 숫자는 1byte, 한글은 3byte로 표현되어 문서의 크기가 작지만 문자의 크기가 가변적이므로 다루기 어렵다는 단점이 있다.

## 4.3 정수형 - byte, short, int, long

정수형에는 총 4가지 자료형이 있으면 1→ 2→ 4→ 8 byte 순으로 커진다. 기본자료형은 int이다.

### 정수형의 표현형식과 범위

자바의 모든 정수형은 부호있는 정수이므로 왼쪽의 첫 번째 비트를 부호비트(sign bit)로 사용하고 나머지 비트를 값을 표현하는데 사용한다. 따라서 정리하면

- **n비트로 표현할 수 있는 정수 개수 : 2^n 개**
- **n비트로 표현할 수 있는 부호있는 정수의 범위:  -2 ^(n-1) ~ 2^(n-1) -1**

부호있는 정수의 범위가 n-1승인 이유는 부호가 있는 정수이므로 맨 첫번째 비트를 부호비트로 사용했기때문이고, 마지막에 양수에서 1을 빼주는 이유는 양수가 0을 포함해서 시작하기 때문이다.

이를  1byte = 8bit 를 예를 들면

- **8비트로 표현할 수 있는 정수의 개수 : 2^8개 (256개)**
- **8비트로 표현할 수 있는 부호있는 정수의 범위 : -2^7 ~ 2^7-1 (-128 ~ 127)**

### 정수형의 오버플로우

먼저 **해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 오버플로우(overflow)** 라고한다. 오버플로우가 발생한다고 해서 에러가 발생하는 것은 아니지만 예상했던 결과를 얻지 못한다.
만약 4bit 2진수의 최대값인 ’1111’을 더하면 ‘10000’이 되지만 4bit는 4자리의 2진수만 저장할 수 없기때문이 ‘0000’이 된다. 이렇듯 정수형 타입이 표현할 수 있는 최대값에 1을 더하면 최소값이 되고, 최소값에서 1을 빼면 최대값이 된다. 그래서 값을 무한히 증가시켜도 ‘0000’ ‘1111’ 범위를 계속 반복한다.

### 부호있는 정수의 오버플로우

부호없는 정수와 부호있는 정수는 표현범위 즉, 최대값과 최소값이 달라서 오버플로우가 발생하는 시점이 다르다.부호없는 정수는 2진수 ‘0000’이 될떄 오버플로우가 발생, 부호있는 정수는 부호비트가 0에서 1이 될때 오버플로욷가 발생한다.
참고로 자바에서는 부호없는 자료형이 ( = 음이 아닌 0과 양수만 표현) char 뿐이며 정수형에서는 부호없는 정수형은 없다.

## 4.4 실수형 - float, double

### 실수형의 범위와 정밀도

![f2](https://github.com/princenim/TIL/assets/59499600/316a1ef8-a5ec-4ee7-a713-1358d1f24123)
자바에서는 실수형을 저장하는 타입으로 float,double 이 있다. 위의 범위는 양의 범위만 적은것으로 -부호를 붙이면 음의 범위가 된다. 예를들어 float로 표현가능한 음의 범위는  `-1.4 x 10 ^45 ~ -3.4 X 10^38`이다.

따라서 float 타입의 표현범위는 `-3.4 X 10^38 ~ 3.4 X10^38` 이지만, `-1.4 X10^45 ~1.4 X 10^-45`범위의 값은 표현할 수 없다. (0 제외) 실수형은 소수점수도 표현해야하므로 얼마나 큰 값을 표현할 수 있는가 뿐만 아니라 얼마나 0에 가깝게 표현할 수 있는가도 중요하다.

왜 실수형 float는 같은 4byte인 정수형인 int와 값을 표현할 수 있는 범위가 다를까? 그 이유는 값을 저장하는 형식이 다르기 때문이다. int타입은 부호와 값으로 이루어진것에 비해 float는 **부호(S),지수(E),가수(M)** 으로 이루어져있다.

![floast](https://github.com/princenim/TIL/assets/59499600/8d621955-fc4b-4dee-ac3a-28ecffda0b91)

따라서 2의 제곱을 곱한형태기 때문에 큰 범위의 값을 저장하는 것이 가능하다. 하지만 정수형과 달리 실수형은 오차가 발생할 수 있다는 단점이 있다. 그래서 실수형은 표현할 수 있는 값의 범위뿐만 아니라 정밀도(precision)이 중요하다 .

float 타입의 정밀도는 7자리, double타입의 정밀도는 15자리인데 따라서  메모리를 절약하려면 float, 높은 정밀도가 필요하면 double타입을 사용해야한다.

```java
float f = 9.12345678901234567890f;

System.out.printf("f : %f%n", f);//소수점 이하 6째자리까지 출력
System.out.printf("f : %24.20f%n", f);

//결과 
//f : 9.123457
//f :   9.12345695495605500000
```

예시를 보면 `%f`를 사용하면 기본적으로 소수점 6짜리까지 (7번째에서 반올림) 되어서 출력된다.  그리고 두번째는 전체 24자리 중에서 20자리는 소수점 이하의 수를 출력하라는 뜻이다. 따라서 소수점 밑의 개수가 20개가 되며 앞뒤의 빈자리가 공백과 0으로 채워졌다. 하지만 정밀도가 7자리이므로 9.123456 까지만 정확히 오차없이 출력됐음을 확인 할 수 있다.

### 실수형의 저장형식

컴퓨터에서 실수를 표현하는 방법은 정수에 비해 훨씬 복잡하다. 왜냐하면 컴퓨터에서는 실수를 정수와 마찬가지로 2지수로만 표현해야하기 때문이다. 

1. 고정 소수점(fixed point)
2. **부동 소수점(floating point)**

2가지 방식이 존재하는데 고정 소수점은 정수부와 소수부로 나눌 수 있다. 소수부의 자릿수를 미리 정해서 고정된 자릿수를 소수로 표현하는 방식이다. 하지만 이 방식은 표현할수 있는 범위가 매우 적다는 단점이 있다.

다음 방식은 부동 소수점 방식인데 자바에서 실수형을 표현할때 이 방식을 쓴다. 실수를 가수부와 지수부로 나누어 표현한다.  위의 그림으로 확인할 수있으며 부호(Sign), 지수(Exponent), 가수(Mantissa) 모두 세 부분으로 이루어져 있다.

- **부호** : 부호비트를 의미. 정수형과 달리 2의 보수법을 사용하지 않기때문에 양의 실수를 음의 실수로 바꾸려면 부호비트만 변경하면 된다.
- **지수** : 지수를 저장하는 공갑으로 float의 는 8bit의 저장공간아 총 256개의 값을 저장할 수 있다.
- **가수**: 실제 값인 가수를 저장하는 부분으로 2진수 23자리를 저장할 수 있다. 2진수 23자리로는 7자리의 10진수를 저장할 수있는데 이것이 바로 float의 정밀도가 된다.

### 실수형의 오버플로우

정수형과 달리 실수형에서는 오버플로우가 발생하면 변수의 값은 무한대가 된다. 그리고 정수형에는 존재하지 않는 **언더플로우(underflow)** 가 있는데 언더플로우는 실수형으로 표현할 수 없는 아주 작은 값. 즉 양의 최소값보다 작은 값이 되는 경우를 말한다.


