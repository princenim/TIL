# 1. 프로세스와 쓰레드

`프로세스(process)`란 실행중인 프로그램을 말한다. 즉 프로그램이 OS로 부터 필요한 자원(메모리)를 할당받아 프로세스가 된다. 이 프로세스의 자원을 이용해 실제로 작업을 수행하는 것이 바로 `쓰레드(thread)`이다.

그래서 모든 프로세스에는 최소한 하나이상의 쓰레드가 존재하며 둘 이상의 쓰레드를 가진 프로세스를 `멀티쓰레드 프로세스(multi-thread process)`라고 한다.

### 멀티태스킹과 멀티쓰레딩

대부분의 OS는 멀티태스킹(다중작업)을 지원하기 때문에 여러 개의 프로세스가 동시에 실행될 수 있다. 이와 마찬가지로 멀티쓰레딩은 하나의 프로세스 안에서 여러 쓰레드가 동시에 작업을 수행하는 것이다. CPU 코어가 한번에 단 하나의 작업만 수행할 수 있으므로 실제로 동시에 처리되는 작업의 개수는 코어의 개수와 일치한다. 하지만 쓰레드의 수는 코어의 개수보다 항상 많으므로 각 코어가 아주 짧은 시간 동안 여러 작업을 번갈아 하며 수행함으로써 여러 작업들이 모두 동시에 수행되는 것처럼 보인다. (= 동시성)

### 멀티쓰레딩의 장단점

- CPU 사용률을 향상시킨다.
- 자원을 보다 효율적으로 사용할 수 있다.
- 사용자에 대한 응답성이 향상된다.
- 작업이 분리되어 코드가 간결해진다.

이러한 장점을 가지고 있지만 멀티쓰레드 프로세스는 여러 쓰레드가 같은 프로세스 내에서 자원을 공유하면서 작업을 하기 때문에 발생할 수 있는 `동기화(synchronization)`, `교착상태(deadlock)`와 같은 문제들을 고려해 신중이 개발해야한다.

# 2. 쓰레드의 구현과 실행

쓰레드를 구현하는 방법은 `Thread 클래스를 상속`받는 방법과 `Runnable 인터페이스를 구현`하는 방법이 있다.

자바는 다중상속이 불가능 하므로 만약 thread 클래스를 상속받는 클래스가 다른 클래스를 상속받아야한다면 Runnable 인터페이스를 구현하는 방법이 일반적이다.

1. Thread 클래스를 상속받는 방법

```java
public class ThreadEx1_1 extends Thread{ //쓰레드 상속
    public void run(){//thread 클래스의 run을 오버라이딩
        for(int i =0; i < 5; i++){
            System.out.println(getName()); //조상인 Thread의 getName() 호출 가능
        }
    }

}
```

1. Runnable 인터페이스를 구현하는 방법

```java
public class ThreadEx1_2 implements Runnable{ // Runnable 인터페이스 구현

    //runnable 인터페이스의 run을 구현
    public void run() {
        for(int i =0; i < 5;i++){
            System.out.println(Thread.currentThread().getName()); //현재 실행중인 쓰레드의 이름을 반환
        }

    }
}
```

그리고 두 방법의 인스턴스 생성 방법은 다르다.

```java
public class ThreadEx1 {
    public static void main(String[] args) {
        //1번 방법 - thread 클래스 상속
        ThreadEx1_1 t1 = new ThreadEx1_1();

        //2번 방법 - Runnable 구현
        ThreadEx1_2 r = new ThreadEx1_2(); //클래스의 인스턴스를 생성
        Thread t2 = new Thread(r); //이 인스턴스를 Thread 클래스 생성자의 매개변수로 제공

        t1.start(); //쓰레드 실행 
        t2.start();
    }
}
```

Runnable 인터페이스를 구현한 경우, 구현한 클래스의 인스턴스를 생성한 다음 이 인스턴스를 Thread 클래스의 생성자의 매개변수로 제공해야한다. Thread 클래스를 상속받으면 자손 클래스에서 조상인 Thread 클래스의 메소드를 직접 호출할 수 있지만. Runnable을 구현하면 Thread 클래스의 static 메소드인 currentThread()를 호출해 쓰레드에 대한 참조를 얻어 와야만 호출이 가능하다.

### 쓰레드의 실행 - start()

쓰레드는 start()를 호출해야만 쓰레드가 실행된다. 그리고 한번 실행이 종료된 쓰레드는 다시 실행할 수 없다. 즉, 하나의 쓰레드에 대해 start()가 두번호출하는건 불가능하다.

# 3. start()와 run()

main메소드에서 `run()`을 호출하는 것은 생성된 쓰레드를 실행시키는 것이 아니라 단순히 클래스에 선언된 메소드를 호출하는 것이다. 반면에 `start()`는 새로운 쓰레드가 작업을 실행하는데 필요한 호출스택을 생성한 다음에 run()을 호출해서 생성된 호출스택에 run()이 첫 번째로 올라가게 한다.

즉 run()을 오버라이딩해서 구현하고 start를 통해 작업을 실행한다.

![thread](https://github.com/princenim/TIL/assets/59499600/1dce5694-beb0-45b6-b98f-9f89237ad3c7)

1. main메서드는 쓰레드의 start()를 호출한다.
2. start()는 새로운 쓰레드를 생성하고 쓰레드가 작업하는데 사용될 호출스택을 생성한다.
3. 새로 생성된 호출스택에 run()이 호출되어 쓰레드가 독립된 공간에서 작업을 수행한다.
4. 이제는 호출스택이 2개이므로 스케줄러가 정한 순서에 의해서 번갈아 가면서 실행된다.

![stack2](https://github.com/princenim/TIL/assets/59499600/1b03389d-cfc8-49be-8357-365c61e46c62)
<img width="1007" alt="스크린샷 2024-02-02 오후 4 19 09" src="https://github.com/princenim/TIL/assets/59499600/3e5b0baa-f6b4-4d17-86a5-96837aabad03">

![st3](https://github.com/princenim/TIL/assets/59499600/1e754de7-f5a7-424a-9414-5d7088f5c939)

모든 쓰레드는 독립적인 작업을 위해 자신만의 호출스택을 필요로 하기 때문에 새로운 쓰레드를 생성하고 실행시킬때마다 새로운 호출스택이 생성되고 쓰레드가 종료되면 사라진다. 더 자세히 설명하면 그림에서 stack memory가 존재하고 이 memory안에 쓰레드별로 스택영역이 존재한다.  따라서 각각의 쓰레드는 서로의 stack 영역을 공유할 수 없다. 또한 쓰레드 별 스택영역에 호출스택에 생성되고 메소드별로 스택프레임이 생기고 이 스택프레임안에 기본자료형에 해당하는 매개변수, 지역변수 리턴값이 저장된다.

또한 스케줄러는 실행대기중인 쓰레드들의 우선순위를 고려해 실행순서와 실행시간을 결정하고, 작성된 스케줄에 따라 자신의 순서가 되면 지정된 시간동안 작업을 수행한다.  그리고 주어진 시간동안 작업을 마치지 못한 쓰레드는 다시 자신의 차례가 돌아올 때까지 대기상태로 있게되며 작업을 마치 스레드는 지춰지면서 쓰레드가 사용하던 호출스택은 사라진다.

그리고 실행중인 쓰레드가 하나도 없을 때 프로그램은 종료된다.

# 4. 싱글쓰레드와 멀티쓰레드

싱글코어일때 하나의 쓰레드로 두 작업을 처리하는 경우는 한 작업을 마친 후 다른 작업을 수행해야한다. 이를 싱글쓰레드라고 하며 두개의 쓰레드로 작업을 하는 경우 짧은 기간동안 2개의 쓰레드를 번갈아 가면서 작업을 수행해야한다. 이렇게 작업할시 오히려 두개의 쓰레드로 작업할때 시간이 더 걸리는데 이는 Context swiching 시간이 걸리기 때문이다. 작업전환을 할때 현재 진행 중인 작업의 상태 예를 들어 다음에 실행해야할 위치등의 정보를 저장하고 읽어오는 시간이 더 걸리므로 오히려 더 많은 시간이 소요된다.

하지만 멀티코어의 경우 동시에 두 쓰레드가 실행될수 있으므로 쓰레드 A와 쓰레드B의 작업이 겹치는 부분이 발생할 수 있고 화면(console)이라는 자원을 두고 두 쓰레드가 경쟁하는 경우가 발생한다. 이때 실행할때마다 다른 경우가 발생할 수 있고 이는 os 프로세스 스케줄러의 영향을 받기 때문이다. 따라서 개발을 할때 쓰레드가 이러한 불확실성을 가지고 있다는 것을 염두에 두어야 한다.

# 5. 쓰레드의 우선순위

쓰레드는 우선순위라는 속성을 갖고있다. 이 우선순위의 값에 따라 스레드가 얻는 실행시간이 달라진다. 따라서 쓰레드가 수행하는 작업의 중요도에 따라 쓰레드의 우선순위를 서로 다르게 저장해 특정 쓰레드가 더 많은 작업시간을 갖도록 할 수있다.

예를들어 메신저의 경우 채팅내용을 전송하는 일이 파일을 다운로드는 하는 일보다 중요하므로 우선순위가 높다.

```java
void setPriority(int newPriority)// 쓰레드의 우선순위를 변경
int getPriority;//쓰레드의 우선순위를 반환
```

쓰레드가 가질 수 있는 우선순위의 범위는 1~ 10이며 숫자가 높을수록 우선순위가 높다. 참고로 main 메소드를 실행하는 쓰레드는 우선순위가 5이다.

# 6. 쓰레드 그룹(thread group)

쓰레드는 그룹을 생성해서 쓰레드를 그룹으로 묶어서 관리할 수 있다. 또한 쓰레드 그룹안에 다른 쓰레드 그룹을 포함시킬 수 있다.

| 생성자/메소드                                                                                                                                                                           | 설명 |
|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------| --- |
| ThreadGroup(String name)                                                                                                                                                          | 지정된 이름의 새로운 스레드 그룹을 생성한다.  |
| ThreadGroup(ThreadGroup parent, String name)                                                                                                                                      | 지정된 쓰레드 그룹에 포함되는 새로운 쓰레드 그룹을 생성한다.  |
| int activeCount()                                                                                                                                                                 | 쓰레드 그룹에 포함된 활성상태에 있는 쓰레드의 수를 반환한다.  |
| void destroy()                                                                                                                                                                    | 쓰레드 그룹과 하위 스레드 그룹까지 모두 삭제한다. 단 쓰레드 그룹이나 하위 쓰레드 그룹이 비워있어야한다.  |
| int enumerate(Thread[] list),<br/> int enumerate(Thread[] list, boolean recurse),<br/> int enumerate(ThreadGroup[] list), <br/>int enumerate(ThreadGroup[] list, boolean recurse) | 쓰레드 그룹에 속한 쓰레드 또는 하위 쓰레드 그룹의 목록을 지정된 배열에 담고 그 개수를 반환한다. 매개변수인 recurse는 값을 true로 하면 쓰레드 그룹에 속한 하위 스레드 그룹에 쓰레드 또는 쓰레드 그룹까지 배열에 담는다.  |
| int getMaxPiority()                                                                                                                                                               | 쓰레드 그룹의 최대 우선순위를 반환한다.  |
| void interrupt()                                                                                                                                                                  | 쓰레드 그룹에 속한 모든 쓰레드를 interrupt |

모든 쓰레드는 반드시 쓰레드 그룹이 포함되어있어야하기때문에 쓰레드 그룹을 지정하는 생성자를 사용하지 않은 쓰레드는 기본적으로 자신을 생성한 쓰레드와 같은 쓰레드 그룹에 속한다. 자바 어플리케이션이 실행되면 JVM은 main과 system이라는 쓰레드 그룹을 만드고 운영에 필요한 쓰레드들 생성해서 이 그룹들에 포함시킨다. 예를 들어 main 메소드를 수행하는 main 이라는 이름의 쓰레드는 main쓰레드 그룹에 속한다.

**즉 우리가 생성하는 모든 쓰레드 그룹은 main 쓰레드 그룹의 하위 쓰레드 그룹이 되며 쓰레드 그룹을 지정하지 않고 생성한 쓰레드는 자동적으로 main쓰레드 그룹에 속한다.**

```java
public class ThreadEx9 {
    public static void main(String[] args) {
        ThreadGroup main = Thread.currentThread().getThreadGroup();
        ThreadGroup grp1 = new ThreadGroup("Group1"); //Group1이라는 이름의 쓰레드 그룹 생성
        ThreadGroup grp2 = new ThreadGroup("Group2");

        ThreadGroup subGrp1 = new ThreadGroup(grp1, "SubGroup1");
        grp1.setMaxPriority(3); //쓰레드 그룹 grp1의 우선순위 3으로 변경. 디폴트 우선순위는 5이다.

        Runnable r = new Runnable() { //인터페이스 익명 클래스로 구현
            @Override
            public void run() {
                try {
                    Thread.sleep(1000);// 해당 쓰레드를 1초간 멈춤
                } catch (InterruptedException e) {
                }
            }
        };

        //start로 쓰레드를 생성하고 Run으로 작업 수행
        new Thread(grp1, r, "th1").start(); //grp1속하는 th1이라는 이름의 쓰레드
        new Thread(subGrp1, r, "th2").start();//subGrp1에 속하는 th2라는 이름의 쓰레드
        new Thread(grp2, r, "th3").start(); //grp2에 속하는 th3이라는 이름의 쓰레드

        System.out.println(">> List of ThreadGroup : " + main.getName() + ", Active ThreadGroup: " + main.activeGroupCount() + ", Active Thread: " + main.activeCount());
        System.out.println("================");
        main.list();

    }

}
```

# 7. 데몬 쓰레드(daemon thread)

데몬 쓰레드는 일반 쓰레드와 달리 작업을 돕는 보조적인 역할을 하는 쓰레드를 말한다. 일반 쓰레드가 종료되면 자바 어플리케이션은 종료되지만 데몬쓰레드는 보조역할을 하므로 다른 일반 쓰레드가 다 종료되었을때 혼자 데몬쓰레드가 살아있다고 하더라도 어플리케이션은 종료된다. 데몬쓰레드의 예로는 가비지 컬렉터, 워드프로세서의 자동저장, 화면자동갱신이 있다.

```java
boolean isDaemon(); //쓰레드가 데몬 쓰레드인지 확인한다. 
void setDaemon(boolean on);//쓰레드를 데몬 쓰레도로 또는 사용자 쓰레도로 변경한다. true일때 데몬쓰레로 변경 
```

```java
public class ThreadEx10 implements Runnable {

    static boolean autoSave = false;

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(3 * 1000);//3초마다
            } catch (Exception e) {
                e.printStackTrace();
            }

            if (autoSave) { //3초마다 변수 autoSave의 값이 true이면 autoSave()를 호출
                autoSave();
            }
        }
    }

    //메인 쓰레드
    public static void main(String[] args) {
        String threadName = Thread.currentThread().getName();
        Thread t = new Thread(new ThreadEx10());
        t.setDaemon(true);//데몬 쓰레드로 설정 반드시 start메소드를 호출하기 전에 실행되어야함.
        t.start(); //데몬쓰레드를 생성하고 사용할 호출 스택을 생성

        for (int i = 0; i <= 10; i++) {
            try {
                Thread.sleep(1000); //1초
            } catch (Exception e) {
                e.printStackTrace();
            }

            System.out.println(threadName + ":" + i);
            if (i == 5) {
                autoSave = true;
            }
        }
    }

    public void autoSave() {
        System.out.println("작업 파일이 자동저장되었습니다. ");
    }

}
```

# 8. 쓰레드의 실행제어

쓰레드 프로그래밍이 어려운 이유는 동기화(syncronization)과 스케줄링(scheduling)때문이다.
쓰레드가 코어의 수보다 많을 경우 쓰레드를 어떤 순서에 의해 실행할 것인가를 결정해야하는 것을 스케줄링이라고 한다.

**스케줄링과 관련된 메소드**는 다음과 같다.

| 메소드                                                                               | 설명 |
|-----------------------------------------------------------------------------------| --- |
| static void sleep(long millis),<br/>static void sleep(long millis, int nanos)     | 지정된 시간동안 쓰레드를 일시정지시킨다. 지정한 시간이 지나고 나면 자동적으로 다시 실행대기상태가 된다.  |
| void join(), <br/> void join(long millis),<br/>void join (long millis, int nanos) | 지정된 시간동안 쓰레드가 실행되도록 한다. 지정된 시간이 지나거나 작업이 종료되면 join()을 호출한 쓰레드로 다시 돌아와 실행을 계속한다.  |
| void inturrupt()                                                                  | sleep()이나 join()에 의해 일시정지 상태인 쓰레드를 깨워서 실행대기상태로 만든다. 해당 쓰레드에서는 InturuptedExcepion이 발생함으로써 일시정지상태를 벗어나게된다.  |
| void suspend()                                                                    | 쓰레드를 일시정지시킨다. resume()을 호출하면 다시 실행대기상태가 된다.  |
| void stop()                                                                       | 쓰레드를 즉시종료 시킨다.  |
| void resume()                                                                     | suspend()에 의해 일시정지상태에 있는 쓰레드를 실행대기 상태로 만든다.  |
| static void yield()                                                               | 실행 중에 자신에게 주어진 실행시간을 다른 쓰레드에게 양보(yield)하고 자신은 실행대기상태가 된다.  |

**쓰레드의 상태**는 다음과 같다.

| 상태 | 설명 |
| --- | --- |
| NEW | 쓰레드가 생성되고 아직 start()가 호출되지 않은 상태 |
| RUNNABLE | 실행 중 또는 실행 가능한 상태 |
| BLOCKED | 동기화블럭에 의해서 일시정지된 상태(lock이 풀릴때까지 기다리는 상태) |
| WAITING, TIMED_WAITING | 쓰레드의 작업이 종료되지는 않았지만 실행가능하지 않은 일시정지 상태. TIMED_WAITING은 일시정지시간이 지정된 경우를 의미한다.  |
| TERMANATED | 쓰레드의 작업이 종료된 상태  |

<img width="731" alt="thread2" src="https://github.com/princenim/TIL/assets/59499600/7163e3ad-16ae-4805-a535-224fcd8e9420">


위의 그림은 쓰레드의 생성부터 소멸까지의 과정을 그림으로 그린것이다.

1. 쓰레드를 생성하고 start()를 호출하면 바로 실행되는 것이 아니라 실행대기열에 저장되어 자신의 차례가 될때까지 기다려야한다. 실행대기열은 큐와 같은 구조로 실행대기열에 들어온 쓰레드가 먼저 실행된다.
2. 실행대기상태에 있다가 자신의 차례가 되면 실행상태가 된다.
3. 주어진 실행 시간이 다되거나 yield() 를 만나면 다시 실행대기상태가 되고 다음 차례의 쓰레드가 실행상태가 된다.
4. 실행중에 suspend(), sleep(), wait(),join() I/O 블록에 의해 일시정지상태가 될 수 있다. 여기서 I/O는 입출력작업에서 발생하는 지연상태를 말한다. 사용자의 입력을 기다리는 경우를 예로 들수 있는데 이런경우 일시정지 상태에 있다가 사용자가 입력을 마치면 다시 실행 대기 상태가 된다.
5. 지정된 일시정지시간이 다되거나(time-out),notify(), interrupt()가 호출되면 일시 정지 상태를 벗어나 다시 실행대기열에 저장되어 자신의 차례를 기다리게된다.
6. 실행을 모두 마치거나 stop()이 호출되면 쓰레드는 소멸된다.



# 9. 쓰레드의 동기화

싱글쓰레드의 프로세스의 경우 프로세스 내에서 단 하나의 쓰레드만 작업하기 때문에 프로세스의 자원을 가지고 작업하는 문제가 없지만, 멀티 쓰레드 프로세스의 경우 여러 쓰레드가 같은 프로세스 내의 자원을 공유해 작업하기 때문에 서로의 작업에 영향을 준다. 만약에 쓰레드 A가 작업하던 도중에 다른 쓰레드B에게 제어권이 넘어갔을 때 쓰레드 A가 작업하던 공유데이터를 쓰레드 B가 변경하였다면 다시 쓰레드 A가 제어권을 받아서 나머지 작업을 마쳤을 때 원래 의도했던 것과는 다른 결과를 얻을 수 있다. 이러한 일을 방지하기 위해 한 쓰레드가 특정 작업을 끝마치기 전까지 다른 쓰레드에 의해 방해받지 않도록 하는 것이 필요하다. 그래서 도입된 개념이 `임계영역(critical section)`과 `잠금(락, lock)`이다.

공유 데이터를 사용하는 **코드 영역을 임계영역으로 지정하고 공유 데이터(객체)가 가지고 있는 Lock을 획득한 단 하나의 쓰레드만 이 영역 내의 코드를 수행할 수 있게 한다. 그리고 해당 쓰레드가 임계영역 내의 모든 코드를 수행하고 벗어나서 lock을 반납해야만 다른 쓰레드가 반납된 lock을 획득해 임계영역의 코드를 수행할 수 있게 된다.** 이렇게 **한 쓰레드가 진행 중인 작업을 다른 쓰레드가 간섭하지 못하도록 막는 것을 쓰레드의 동기화(syncronization)라고 한다.**  그리고 모든 객체는 락을 lock를 하나씩 가지고 있다.

## 9.1 synchronized를 이용한 동기화

`synchronized` 키워드를 이용한 동기화 방법은 크게 2가지가 존재한다.

### **메서드 영역 전체를 임계영역으로 지정**

쓰레드는 `syncrhonized` 메소드가 호출된 시점부터 해당 **메소드가 포함된 객체의 lock을 얻어** 작업을 수행하다가 메소드가 종료되면 lock을 반환한다.

```java
public syncronized void calcSum(){ //메서드 전체가 임계영역

}
```

### **특정한 영역을 임계 영역으로 지정**

메소드 내에 코드 일부를 `블럭{}` 으로 감싸고 블럭 앞에 `synchronized(참조변수)` 를 붙이는 방법으로  이때 참조변수는 락을 걸고자 하는 객체를 참조하는 것이어야 한다. 이 블럭의 영역 안으로 들어가면서부터 쓰레드는 지정된 객체의 `lock`을 얻게 되고 이 블럭을 벗어나면 `lock`을 반환한다.

```java
public void method(...) {
		syncronized(객체의 참조변수){
	}
}

```

그리고 이 `synchronized` 블록은 **2가지의 사용방법**이 존재한다.

### **synchronized(this)**

```java
public class Block1 {

    public static void main(String[] args) {
        Block1 block = new Block1();

        //람다식으로 쓰레드1 생성
        Thread thread1 = new Thread(
                () -> {
                    System.out.println("쓰레드 시작1 :" + LocalDateTime.now());
                    block.syncBlockMethod1("쓰레드1");
                    System.out.println("쓰레드 1 종료" + LocalDateTime.now());
                }
        );

        //람다식으로 쓰레드2 생성
        Thread thread2 = new Thread(
                () -> {
                    System.out.println("쓰레드 시작2 :" + LocalDateTime.now());
                    block.syncBlockMethod2("쓰레드2");
                    System.out.println("쓰레드 2 종료" + LocalDateTime.now());
                }
        );

        thread1.start();
        thread2.start();

    }

    private void syncBlockMethod1(String msg) {
        synchronized (this) { //this는 Block1 의 객체를 말함.
            System.out.println(msg + "의 syncBlockMethod1 실행 중" + LocalDateTime.now());

            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void syncBlockMethod2(String msg) {
        synchronized (this) { //this는 Block1 의 객체를 말함.
            System.out.println(msg + "의 syncBlockMethod2 실행 중" + LocalDateTime.now());

            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

```

<img width="712" alt="1" src="https://github.com/princenim/TIL/assets/59499600/88810f0d-0e7a-4e9f-ab19-645393245f6b">

```java
//결과
쓰레드 시작2 :2024-02-08T16:45:23.262817
쓰레드 시작1 :2024-02-08T16:45:23.262817
쓰레드2 의 syncBlockMethod2 실행 중2024-02-08T16:45:23.264809
쓰레드 2 종료2024-02-08T16:45:28.282979
쓰레드1 의 syncBlockMethod1 실행 중2024-02-08T16:45:28.282979
쓰레드 1 종료2024-02-08T16:45:33.284676
```

먼저 `this`는 클래스의 인스턴스 메모리 주소를 가리킨다. 즉 클래스가 다른 객체를 생성했을때는 this는 서로 다른 객체를 가리킨다.   `sybchronized` 블록에 `this`를 사용하면 모든 `synchronized` 블록에 하나의 객체에 같은 락을 사용하므로 한 `synchronized` 블럭이 끝나고 락이 반환될때까지 다른 모든 `synchronized`  블록은 사용할 수 없다.

(위의 코드에서 다른 메소드가 다른 쓰레드에서 생성이 되므로 왜 동기화를 해줘야하지라고 생각할수있는데  두 메소드에 공유자원이 존재한다고 할때 생각하면 문제가 발생한다. 결국은 this은 다른 synchronized 이 존재할때 모두 같은 락을 가지게 되므로 기다리는 쓰레드가 멈춰서 기다리는 현상이 발생한다.)

따라서  블록마다 다른 락을 갖게 하는 방법이 `synchronized(Object)`방식이다.

### **synchronized(Object)**

```java
public class Block2 {

    private final Object o1 = new Object();
    private final Object o2 = new Object();

    public static void main(String[] args) {
        Block2 block = new Block2();

        //람다식으로 쓰레드1 생성
        Thread thread1 = new Thread(
                () -> {
                    System.out.println("쓰레드 시작1 :" + LocalDateTime.now());
                    block.syncBlockMethod1("쓰레드1");
                    System.out.println("쓰레드 1 종료" + LocalDateTime.now());
                }
        );

        //람다식으로 쓰레드2 생성
        Thread thread2 = new Thread(
                () -> {
                    System.out.println("쓰레드 시작2 :" + LocalDateTime.now());
                    block.syncBlockMethod2("쓰레드2");
                    System.out.println("쓰레드 2 종료" + LocalDateTime.now());
                }
        );

        thread1.start();
        thread2.start();

    }

    private void syncBlockMethod1(String msg) {
        synchronized (o1) { //o1이라는 이름의 객체 락을 가짐
            System.out.println(msg + " 의 syncBlockMethod1 실행 중" + LocalDateTime.now());

            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    private void syncBlockMethod2(String msg) {
        synchronized (o2) { //o2라는 이름의 객체 락을 가짐
            System.out.println(msg + " 의 syncBlockMethod2 실행 중" + LocalDateTime.now());

            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```

<img width="711" alt="2" src="https://github.com/princenim/TIL/assets/59499600/461b8e26-b719-4360-9fed-66dbd34b22d5">

이렇게 `this`가 아닌 객체를 따로 만들어 블럭이 갖는 객체의 락을 다르게 해주면 `synchronized 블록`은 서로 동시에 실행할 수 있다. 그리고 이때 만드는 `o1`, `o2`는 락을 위해서만 사용하는 임시객체이므로 어느것으로 만들어도 상관없다.

즉 정리하면 `this` 방식은 모든 블럭에 `lock`이 걸리므로 상황에 따라 비효율적일 수있다. 하지만 `Object` 방식은 블록마다 다른 `lock`을 걸리게 하여 효율적으로 코드를 작성할 수 있다.

### synchrnonized 예제

```java
public class ThreadEx21 {
    public static void main(String[] args) {
        //메인 쓰레드
        RunnableEx21 r = new RunnableEx21();
        new Thread(r).start(); //쓰레드 2개
        new Thread(r).start();
    }
}

class Account {
    private int balance = 1000;//잔고

    public int getBalance() { //잔고 확인 메소드
        return balance;
    }

    public void withdraw(int money) { //출금 메소드
        if (balance >= money) {
            try {
                Thread.sleep(1000); //해당 쓰레드를 1초간 슬립
            } catch (Exception e) {
                e.printStackTrace();
            }

            balance -= money;
        }
    }
}

class RunnableEx21 implements Runnable { //쓰레드를 구현

    Account account = new Account();

    @Override
    public void run() {
        while (account.getBalance() > 0) {
            //Math.random은 0.0 ~ 1에 랜덤 숫자를 리턴
            //* 3은 0 ~ 3까지의 숫자를 한환
            //+1은 1~ 4 로 변환
            //int로 변환해 정수값만 가지게 함
            //* 100은 100 ~ 400사이의 숫자를 반환
            int num = (int) (Math.random() * 3 + 1) * 100;
            account.withdraw(num);//출금
            System.out.println("balance:" + account.getBalance());
        }
    }
}
```

위의 코드를 실행하면 결과가 - 가 나오는것을 확인할 수 있다. 이는 한 쓰레드가 이 if문을 통과하고 출금을 수행하려는 순간 다른 쓰레드가 200을 출금해 잔고가 0이 되고   제어권이 다른 쓰레드로 넘어갔을때 잔고가 0인 상태에서 100을 출금해 -100이된다.

따라서 이러한 동시성 문제를 해결하기 위해서 `synchronized` 키워드를 붙여 동기화를 해야한다. 키워드를 붙임으로써 한 쓰레드가 withdraw()를 호출하면 이 메서드가 종료되어 lock를 반납하기전까지 다른쓰레드는 대기상태에 머무른다.

만약 메소드에 synchronized 를 붙이는 대신 synchronized 블럭을 사용하면 다음과 같다.

```java
public void withdraw(int money) { //출금 메소드

        synchronized (this) { //this는 해당 클래스의 인스턴스의 메모리주소를 가리킴
            if (balance >= money) {
                //한 쓰레드가 이 조건문을 통과하고 출금을 수행하려는 순간 다른 쓰레드가 200을 출금해 잔고가 0이 된다면
                // 다시 제어권이 다른 쓰레드로 넘어갔을 때 잔고가 0인 상태에서 100을 출금해 -100이된다.
                //따라서 synchronized 키워드를 붙여야함.
                try {
                    Thread.sleep(1000); //해당 쓰레드를 1초간 슬립
                } catch (Exception e) {
                    e.printStackTrace();
                }

                balance -= money;
            }
        }
    }
```

또한 위의 코드에서 중요한 점은 balance의 접근 제어자가 private이다. 만약 private가 아니면 외부에서 직접 변경할 수 있기때문에 아무리 동기화를 해도 이 값의 변경을 막을 방법이 없다. 따라서 변수의 값 변경을 막기위해 private로 지정해야한다.

## 9.2 wait()과 notify()

`syncronized`로 동기화해서 공유 데이터를 보호하는 것은 좋지만 특정 쓰레드가 객체의 락을 가진 상태로 오랜 시간을 보내지않도록 해야한다. 만약 한 쓰레드가 락을 오래 갖고있는다면 다른 쓰레드들은 모두 해당 객체의 락을 기다리느라 다른 작업을 원활히 진행할 수 없을 것이다.

이러한 상황을 개선하기 위해 등장한 것이 `wait()`과 `notify()`이다. 동기화된 임계영역의 코드를 수행하다가 작업을 더 이상진행할 상황이 아니면 일단 **wait()을 호출하여 쓰레드가 락을 반납하고 기다린다.** 그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있다. 그리고 후에 작업을 진행할 수 있는 상황이 되면 **notify() 를 호출해서 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수있다.** 이때 스스로 기다리고 있는 쓰레드가 스스로 notify()를 호출하는 것이 아니라 락을 얻어 락을 사용하고 있는 쓰레드가 notify()를 호출하는 것이다.

```java
//모두 Object에 정의되어있으며,  동기화(synchronized)블록안에서만 사용 가능 

void wait() //현재쓰레드를 다른쓰레드가 이 객체에 대해 nofify()나 notifyAll()의 호출을 기다린다. 
void wait(long timeout)
void wait(long timeout, int nanos)

void notify()  //이 객체에 대해 대기중인 쓰레드 하나를 깨운다. 
void notifyAll()// 이 객체에 대해 대기중인 모든 쓰레드를 깨운다. 
```

하지만 이 방법은 오래 기다린 쓰레드가 락을 얻는다는 보장이 없다. wait()이 호출되면 실행 중이던 쓰레드는 해당 객체의 대기실(waiting pool)에서 통지를 기다린다. 그리고 notify()가 호출되면 해당 객체의 대기실에 있던 모든 쓰레드 중에서 임의의 쓰레드만 통지를 받는다.

notifyAll()은 기다리고 있는 waiting pool의 모든 쓰레드에게 통보를 하지만 그래도 lock을 얻을 수 있는 쓰레드는 하나뿐이고 나머지 쓰레드는 lock을 얻지 못 하면 다시 lock를 기다릴수 밖에없다.

중요한 것은 waiting pool은 객체마다 존재하는 것이므로 notifyAll()이 호출된다고 해서 모든 객체의 waiting pool이 있는 쓰레드가 깨워지는 것이 아니다. notifyAll()이 호출된 객체의 waiting pool에 대기 중인 쓰레드만 해당한다.

```java
public class ThreadWaitEx1 {
    public static void main(String[] args) throws InterruptedException {
        Table table = new Table();

        //쓰레드 3개 생성
        new Thread(new Cook(table),"COOK1").start(); //구현한 클래스의 인스턴스와 쓰레드 이름
        new Thread(new Customer(table, "donut"),"CUST1").start();
        new Thread(new Customer(table, "burger"), "CUST2").start();

        Thread.sleep(100);//이 쓰레드를 0.1초 쉬고
        System.exit(0); //프로그램 정체 종료 즉 모든 쓰레드 종료
    }
}

public class Table {
    String[] dishNames = {"donut", "donut", "burger"};
    final int MAX_FOOD = 6; //테이블에 놓을 수 있는 최대 음식의 개수

    private ArrayList<String> dishes = new ArrayList<>(); //음식 배열

    public void add(String dish) {
        //테이블에 음식이 가즏 차면 테이블에 음식을 추가하지 않는다.
        if (dishes.size() >= MAX_FOOD) {
            return;
        }
        dishes.add(dish);
        System.out.println("Dishes:" + dishes.toString());
    }

    public boolean remove(String dishName) {
        //지정된 요리와 일치하는 요리를 테이블에서 제거한다.
        for (int i = 0; i < dishes.size(); i++) {
            if (dishName.equals(dishes.get(i))) {
                dishes.remove(i);
                return true;
            }

        }
        return false;
    }

    public int dishNum() {
        return dishNames.length;
    }
}
```

```java
public class Customer implements Runnable {
    //테이블의 음식을 소비하는 소비자
    private Table table;
    private String food;

    Customer(Table table, String food) {
        this.table = table;
        this.food = food;
    }

    @Override
    public void run() {
        while (true) {
            try {
                Thread.sleep(10);
            } catch (Exception e) {
                e.printStackTrace();
            }
            String name = Thread.currentThread().getName();

            if (eatFood()) {
                System.out.println(name + " ate a " + food); //name은 쓰레드 이름
            } else {
                System.out.println(name + " failed to eat. : (");
            }
        }

    }
    boolean eatFood() { //음식 제거
        return table.remove(food);
    }
}

public class Cook implements Runnable {
    //음식을 만들어서 테이블에 추가
    private Table table;

    Cook(Table table){
        this.table = table;
    }
    @Override
    public void run() {

        while (true){
            //임의의 요리를 하나 선택해서 table에 추가
            int idx =(int)(Math.random() * table.dishNum());
            table.add(table.dishNames[idx]);
            try {
                Thread.sleep(1);
            }catch (InterruptedException e){
                e.printStackTrace();
            }
        }
    }
}
```

다음은 식당에서 음식(dish)을 만들어 테이블(table)에 추가(add)하는 요리사(cook)와 테이블의 음식을 소비(remove)하는 손님(customer)을 쓰레드로 구현한 예제이다

해당 예제를 실행하면 오류가 뜨는데 그 이유는 하나는 요리사 쓰레드가 테이블에 음식을 놓는 도중에 손님 쓰레드가 음식을 가져가려해서 발생하는 예외이고, 다른 하나는 손님쓰레드가 마지막 남은 음식을 가져가는 도중에 다른 손님 쓰레드가 먼저 음식을 가져가 있지도 않은 음식을 제거하려해서 발생하는 예외이다.

이런 예외들을 방지하려면 동기화를 추가해야한다.

```java
public class Table {
    String[] dishNames = {"donut", "donut", "burger"};
    final int MAX_FOOD = 6; //테이블에 놓을 수 있는 최대 음식의 개수

    private ArrayList<String> dishes = new ArrayList<>(); //음식 배열

    public synchronized void add(String dish) { //동기화추가

        //테이블에 음식이 가즏 차면 테이블에 음식을 추가하지 않는다.
        if (dishes.size() >= MAX_FOOD) {
            return;
        }
        dishes.add(dish);
        System.out.println("Dishes:" + dishes.toString());
    }

    public boolean remove(String dishName) {

        synchronized (this) { //synchronized 블럭 추가 this는 현재 블럭이 속한 클래스의 인스턴스를 말함 즉 여기서는 table
            //0.5초마다 음식이 추가되었는지를 확인
            while (dishes.size() == 0) {
                String name = Thread.currentThread().getName(); //현재 쓰레드 이름
                System.out.println(name + " is waiting.");
                try {
                    Thread.sleep(500); //0.5초 쉬기 10000이 1초
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            //지정된 요리와 일치하는 요리를 테이블에서 제거한다.
            for (int i = 0; i < dishes.size(); i++) {
                if (dishName.equals(dishes.get(i))) {
                    dishes.remove(i);
                    return true;
                }
            }
        }
        return false;
    }

    public int dishNum() {
        return dishNames.length;
    }
}
```

이렇게 Table의 add와 remove를 synchronized 를 통해 동기화하였다. 하지만 이 예제를 실행하면

요리사 쓰레드는 음식을 추가하지 않고 계속 손님 쓰레드를 기다린다. 이 이유는 손님 쓰레드가 테이블 객체의 락을 갖고있기때문이다. 따라서 요리사 쓰레드는 음식을 추가하려고 해도 락을 얻지 못해서 추가할수없는 것이다.

이럴때 사용할수있는 것이 watit() & join() 이다. wait()으로 락을 풀고 기다리다가 음식이 추가되면 notify() 로 통보를 받고 다시 락을 얻어 나머지 작업을 하게 하는 것이다.

```java
public class Table {
    String[] dishNames = {"donut", "donut", "burger"};
    final int MAX_FOOD = 6; //테이블에 놓을 수 있는 최대 음식의 개수
    private ArrayList<String> dishes = new ArrayList<>(); //음식 배열

    public synchronized void add(String dish) { //동기화 추가

        //테이블에 음식이 가즏 차면 테이블에 음식을 추가하지 않는다.
        if (dishes.size() >= MAX_FOOD) {
            String name = Thread.currentThread().getName();
            try {
                System.out.println(name + " is waiting."); //손님이 먹을때까지 기다림
                wait();// Cook 쓰레드를 기다리게한다. 즉 객체에 대해 대기중인 쓰레드 하나를 깨운다.
                Thread.sleep(500); //0.5초
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        dishes.add(dish); //테이블에 음식 추가
        
        notify();// 기다리고 있는 CUST를 꺠우기 위함.
        System.out.println("Dishes:" + dishes.toString());
    }

    public boolean remove(String dishName) {

        synchronized (this) { //synchronized 블럭 추가 this는 현재 블럭이 속한 클래스의 인스턴스를 말함 즉 여기서는 table의 객체

            String name = Thread.currentThread().getName(); //현재 쓰레드 이름
            //0.5초마다 음식이 추가되었는지를 확인
            while (dishes.size() == 0) {
                System.out.println(name + " is waiting.");
                try {
                    wait(); //CUST(Customer) 쓰레드를 기다리게 한다.
                    Thread.sleep(500); //0.5초 쉬기 10000이 1초
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }

            while (true) {
                for (int i = 0; i < dishes.size(); i++) {
                    if (dishName.equals(dishes.get(i))) {
                        dishes.remove(i);
                        notify(); //잠자고 있는 COOK을 깨우기 위함
                        return false;
                    }

                }

                try {
                    System.out.println(name + "is waiting.");
                    wait(); //원하는 음식이 없는 CUST 쓰레드를 기다리게한다.
                    Thread.sleep(500);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public int dishNum() {
        return dishNames.length;
    }
}
```

하지만 이런 방법은 테이블 객체의 waiting pool에 요리사 쓰레드와 손님 쓰레드가 같이 기다리게 된다. 그래서 noftify()가 호출되었을 때 waiting pool에 있는 어느 쓰레드가 통지 받을지 알 수 없다. 만약에 테이블에 음식이 없어서 notify()가 호출된다면 요리사 쓰레드가 통지를 받아야하지만 wating pool 에 대기 중인 쓰레드 중에서 하나가 랜덤으로 통지받을 수있다. 따라서 요리사 쓰레드가 아닌 손님 쓰레드가 통지 받을 수 있는데 이때 lock을 얻어도 여전히 자신이 원하는 음식이 없어서 waiting pool에 들어가게된다.

### 기아현상과 경쟁상태

위와 같이 운이 나쁘면 요리사 쓰레드는 계속 통지를 받지 못하고 오랫동안 기다리게 되는데 **이렇게 쓰레드가 계속해서 제어권을 할당 받지 못하고 장시간 대기하고 있는 현상을 기아(starvation)현상이라고 한다.** 이러한 현상을 막으려면 notifty()가 아닌 notifyAll()를 사용해 모든 쓰레드에게 통지를 하면 손님 쓰레드는 다시 wating pool에 들어가더라도 요리사 쓰레드는 락을 얻어서 작업을 진행할 수 있다.

하지만 이때 손님쓰레드와 요리사쓰레드가 락을 얻기위해 경쟁을 하게 되는데 이렇게 **여러 쓰레드가  여러쓰레드가 lock을 얻기위해 서로 경쟁하는 것을 경쟁상태(race condition)** 이라고 한다.

이 경쟁상태를 개선하기 위해서는 요리사 쓰레드와 손님쓰레드를 구별해서 통지하는 것이 필요하다. 이는 Lock과 Condition을 이용하면 wait()과 notify()로는 불가능한 선별적인 통지가 가능하다.