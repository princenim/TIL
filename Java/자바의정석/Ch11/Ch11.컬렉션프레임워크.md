# 1. 컬렉션 프레임워크(Collections Framework)

컬렉션 프레임워크이란 데이터를 저장하는 클래스들을 표준화한 설계를 말한다. 컬렉션은 데이터 그룹을 프레임워크는 표준회된 프로그래밍 방식을 의미한다.

컬렉션 프레임워크는 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 덜어주고, 인터페이스와 다양한 객체지향적 설계를 통해 표준화되어있기때문에 사용법을 익히기에도 편리하다.

## 1.1 컬렉션 프레임워크의 핵심 인터페이스

컬렉션 프레임워크에서는 컬렉션 데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의했다.

![img](https://github.com/princenim/TIL/assets/59499600/54ffb144-6149-4797-b19e-d1ae6b2a6c79)

List, Set을 구현한 컬렉션 클래스들은 서로 많은 공통점이 있어 공통된 부분을 뽑아 다시 Collection 프레임워크로 정의할 수 있었지만 Map 인터페이스는 이들과는 다르게 다른 형태로 다루기 때문에 같은 상속도계층도에 포함되지 못했다. 이러한 설계는 객체지향언어의 장점을 극명히 보여준다. 따라서 프로그래밍 실력을 어느정도 갖추게 되었을 때 컬렉션 프레임워크의 실제 소스를 분석해보면 객체지향적인 설계능력을 향상시키는데 많은 도움이 될 것이다.

- `List` : 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. - ArrayList, LinkedList, Vector
    - e.g. 대기자 명단
- `Set` : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.  - HashSet, TreeSet
    - e.g. 양의 정수집합, 소수의 집합
- `Map` : 키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않으나, 값은 중복을 허용한다. - HashMap, TreeMap, HashTable, Properites
    - e.g. 우편번호, 지역번호


컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set , Map 중 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다. 그러나 Vector, Stack , Hashtable, Properties 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이므로 컬렉션 프레임워크 명명법을 따르지 않는다.

따라서 Vector, Hashtable 과 같은 기존 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨주었지만 가능하면 사용하지 않는 것이 좋다. 대신 ArrayList와 Hashmap을 사용하다.

### List 인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다. ArrayList, LinkedList , Stack

List 인터페이스에 정의된 메서드 목록

| 메서드                                                                          | 설명 |
|------------------------------------------------------------------------------| --- |
| void add(int index, Object element) ,boolean addAll(int index, Collection c) | 지정된 index에 객체(element) 또는 객체들(Collection )을 추가한다.  |
| Object get(int index)                                                        | index에 있는 객체를 반환한다.  |
| int indexOf(Object o)                                                        | 지정된 객체의 index를 반환한다. (List 첫번째 요소부터 순방향으로) |
| int lastIndexOf(Object o)                                                    | 지정된 객체의 index를 반환한다. (List 마지막 요소부터 순방향으로) |
| ListIterator listItertor(), ListIterator listItertor(int index)                                          | List의 객체에 접근할 수 있는 ListIterator 를 반환한다.  |
| Object remove(int index)                                                     | index에 있는 객체를 삭제하고 삭제된 객체를 반환한다.  |
| Object set(int index, Object element)                                        | index에 객체를 저장한다.  |
| void sort(Comparator c)                                                      | 지정된 비교자로 부터 List를 정렬한다. (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(int fromIndex, int toIndex)                                     | 지정된 범위에 있는 객체를 반환한다. from ~ to |

```java
//ListIterator 
LinkedList<String> list = new LinkedList<String>();
list.add("A");
list.add("B");
Iterator<String> iter = list.iterator();

while(iter.hasNext()) { //has.Next는 읽을 다음 여부가 있는지 반환
    System.out.println(iter.next()); //next()는 다음요소를 읽어온다.  
}
```

### Set 인터페이스

중복을 허용하지 않고 저장순서가 유지 되지 않는 컬렉션 클래스를 구현할때 사용한다. HashSet, TreeSet.

### Map 인터페이스

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용된다. 키는 중복될수 없고, 값은 중복을 허용한다.기존에 저장된 데이터와 중복된 키에 값을 저장하면 기존의 값은 없어지고, 마지막에 저장된 값이 남겨진다. Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap

| 메서드  | 설명  |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다.  |
| boolean containsKey(Object Key) | 지정된 key 객체와 일치하는 Map의 Key 객체가 있는지 확인한다.  |
| boolean containsKey(Object Value) | 지정된 value 객체와 일치하는 Map의 value객체가 있는지 확인한다.  |
| Set entrySet() | Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.  |
| boolean equals(Object o) | 동일한 Map 인지 비교한다.  |
| Object get(Object key ) | 지정한 Key 객체에 대응하는 value객체를 찾아서 반환한다.  |
| int hashCode() | 해쉬코드를 반환한다. 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값을 말한다.  |
| boolean isEmpty() | Map이 비어있는지 확인한다.  |
| Set keySet() | Map에 저장된 모든 Key객체를 반환한다.  |

참고로 Object는 자바가 만들어놓은 API 중에서 최상위 클래스이다. 모든 사용자가 만든 클래스는 Object로부터 상속받는다. 따라서 모든 클래스는 Object 클래스릐 메서드를 사용할 수 있다.
객체 또는 Object는 클래스에서 정의한 것을 토대로 메모리에 할당된 것을 말한다. 따라서 메모리가 할당되기 전까지 객체는 존재하지 않는다. 객체 지향 프로그래밍에서 객체는 클래스의 인스턴스다 .

keySet() 의 반환타입은 Set 이며, value() 반환타입은 Collection 이라는 것에 주목하자. Map 인터페이스에서 값은 중복을 허용하기 때문에 Collection 타입으로, key는 중복을 허용하지 않기 때문에 set 타입으로 반환한다.

### Map.Entry 인터페이스

Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것도 가능하다.
Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해놓았다. 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map 인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스를 함께 구현해야한다.

## 1.2 ArrayList

ArrayList는 List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고, 중복을 허용한다는 특징을 갖는다. ArrayList는 Object 배열을 이용해 데이터를 순차적으로 저장한다. 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장한다.

| 메서드  | 설명                                                                                                    |
| --- |-------------------------------------------------------------------------------------------------------|
| ArrayList() | 크기가 10인 ArrayList를 생성                                                                                 |
| ArrayList(Collection c) | 주어진 컬렉션이 저장된 ArrayList를 생성                                                                            |
| ArrayList(int initialCapacity) | 지정된 컬렉션이 저장된 ArrayList를 생성                                                                            |
| boolean add(Object o) | ArrayList에 마지막에 객체를 추가. 성공하면 true                                                                     |
| void add(int index, Object element) | 지정된 index에 객체를 저장                                                                                     |
| boolean addAll(Collection c) | 주어진 컬렉션의 모든 객체를 저장, 즉 붙이기                                                                             |
| void clear() | ArrayList를 완전히 비운다.                                                                                   |
| Object clone() | ArrayList를 복제한다.                                                                                      |
| boolean contains(Object o) | 지정된 객체(o)가 ArrayList에 포함되어있는지 확인                                                                      |
| void ensureCapacity(int minCapacity) | ArrayList의 용량이 최소한 minCapacity에 포함되어 있는지 확인                                                           |
| Object get(int index) | index에 저장된 객체를 반환                                                                                     |
| int indexOf(object o) | 지정된 객체가 저장된 위치를 찾아 반환                                                                                 |
| boolean isEmpty() | ArrayList가 비어있는지 확인                                                                                   |
| Iterator iterator() | ArrayList의 Iterator객체를 반환                                                                             |
| int lastIndexOf(Object o) | 객체 o가 저장된 위치를 역방향으로 검색해서 반환                                                                           |
| ListIterator listIterator() | ArrayList의 ListIterator 반환                                                                            |
| ListIterator listIterator(int index) | ArrayList의 지정된 위치부터 시작하는 ListIterator 반환                                                              |
| Object remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean removeAll(Collection c) | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거                                                               |
| boolean retainAll(Collection c) | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만 남기고 다 삭제                                                       |
| Object set(int index, Object elemet) | 주어진 객체를 지정된 index에 저장                                                                                 |
| int size() | ArrayList에 저장된 객체의 개수 반환                                                                              |
| void sort(Comparator c) | 지정된 정렬기준으로 ArrayList 정렬  (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(intfromIndex, int toIndex) | fromIndex 부터 toIndex까지에 저장된 객체를 반환                                                                    |
| Object[] toArray() | ArrayList에 저장된 모든 객체들을 객체배열로 반환                                                                       |
| Object[] toArray(Object[] a) | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환                                                                  |
| void trimToSize() | 용량을 크기에 맞게 줄인다. 즉 빈 공간을 없앤다.                                                                          |

```java
//ArrayList 선언 
ArrayList<String> a1 = new ArrayList<String>(); //타입지정해서 선언,기본 capacity는 10
a1.add("A"); //ArrayList 마지막에 객체 추가
a1.add("B");
ArrayList<String> a2= new ArrayList<String>(50); //초기 capacity를 50으로
a2.add("C");
ArrayList<String> a3= new ArrayList<String>(a1); //주어진 Collection을 초기값으로 생성

//붙이기 addAll
System.out.println(a2.addAll(a3)); //a2 +a3 -> true
System.out.println(a2); //[C, A, B]

//복제 clone
Object a4 = a2.clone();
System.out.println(a4); //[C, A, B]

//컬렉션에 저장된 것과 동일한 객체들을
a2.removeAll(a3); // [C, A, B] - [A,B] = [C]
System.out.println(a2);
```

예제 11-2) 긴 문자열 데이터를 원하는 길이로 잘라서 ArrayList에 담은 다음 출력

```java
public static void main(String[] args) {
    final int LIMIT = 10; //자르고자 하는 글자 개수
    String source = "0123456789abcdefghijABCDEFGHIJ!@#$%^&*()ZZZ";
    int length = source.length();

    //초기 용량이 14인 리스트
    ArrayList<String> list = new ArrayList<>(length / LIMIT + 10); //여유있게 크기 잡기 48/10 + 10 = 14

    for (int i = 0; i < length; i += LIMIT) { //i = 0,10, 20, 30,40
        if (i + LIMIT < length) {
            //add는 ArrayList 마지막에 객체 추가
            list.add(source.substring(i, i + LIMIT));
        } else {
            list.add(source.substring(i));
        }
    }
    System.out.println(list);
}
```

### + Array와 ArrayList의 차이

Array와 ArrayLIst는 모든 것이 비슷하나, 가장 큰 차이점은 길이를 조정할 수 있는가 없는가이다.

자바에서 Array는 **고정길이**이다. 초기화시 배열의 크기를 지정한다. 또한 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어줘야한다.

하지만 ArrayList는 List컬렉션 인터페이스의 한 종류로 **가변길이**이다.  즉 동적으로 사이즈가 늘어난다. 하지만 내부적으로 Array로 구성되어 있다. ArrayList는 디폴트로 10개의 공간을 가진 배열로 시작한다. 따라서 기존 사이즈 이상으로  add()함수를 이용해 추가하려고하면 기존 배열 크기의 1.5배(기존용량 + 기존용량/2)로 resize해 새로운 배열을 만들어서 기존배열을 copy한다. 이런 원리로 ArrayList가 동적으로 크기가 늘어날 수 있는 것이다.


## 1.3 LinkedList

배열은 구조가 간단하여 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만, 다음과 같은 **단점**을 가지고 있다.

- 크기를 변경할 수 없다. - 크기를 변경할 수 없으므로 새로운 배열을 생성해 데이터를 복사해야한다.
- 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.  - 차례대로 데이터를 추가하고 , 마지막부터 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야한다.

이러한 배열의 단점을 보완하기 위해서 LinkedList라는 자료구조 형태가 나왔다. **링크드리스트는 메모리상에서 불연속적으로 존재하는 데이터를 서로 연결한 형태**로 구성되어있다.

<img width="614" alt="a" src="https://github.com/princenim/TIL/assets/59499600/01f8dd9f-777e-443a-bb8a-72a3866031db">

![b](https://github.com/princenim/TIL/assets/59499600/0cf1c93a-8e28-4173-9790-82bada38d540)

링크드리스트의 각 요소(Node)들은 자신과 연결된 다음 요소에 대한 **참조(주소값)과 데이터**로 구성되어 있다.

```java
class Node{
  Node next; //다음 요소의 주소를 저장
  Object obj; // 데이터를 저장
}
```

링크드 리스트의 삭제는 간단한데. 삭제하고자하는 요소의 이전요소가 삭제하고자하는 요소의 다음 요소를 참조하다록만 변경하면 된다. 새로운 데이터를 추가할 때는 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소로 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 된다.

참고로 Linkedlist는 ArrayList와 달리 인덱스가 존재하지 않는다. 따라서 순차탐색이 필요하다.

### 더블 링크드 리스트

![c](https://github.com/princenim/TIL/assets/59499600/eb6470ed-9604-4843-98e1-7f6b3d0d3f32)

하지만, 이런 링크드 리스트 이동방향이 단방향이기때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접은은 어렵다. 예를들어 링크드 리스트에 저장된 데이터가 10000개라면 9999번째 데이터에 접근하려면 9999번 이동해야한다. 이러한 단점을 해결한것이 **더블 링크드 리스트 (이중 연결리스트, doubly linked list) 이다.** 링크스 리스트에 참조변수를 하나 더 추가해 다음 요소에 대한 참조뿐만이 아니라 이전 요소에 대한 참조가 가능하도록 했다.

```java
class Node{
  Node next; //다음 요소의 주소를 저장
  Node previous; //이전 요소의 주소를 저장
  Object obj; // 데이터를 저장
}
```

### 더블 써큘러 링크드 리스트

<img width="720" alt="d" src="https://github.com/princenim/TIL/assets/59499600/e28ea4fd-2077-4323-9692-ef2cc231448a">

더블 링크르 리스트의 접근성을 보다 향상시킨 것이 더블 서큘러 링크드 리스트(이중 원형 연결리스트, doubly circular linked list)이다. 단순히 더블 링크드 리스트의 첫번째와 마지막 요소를 서로 연결시킨 것이다. 따라서 마지막 요소의 다음 요소가 첫번째 요소가 되고, 첫번째 요소의 이전 요소가 마지막 요소가 된다. 따라서 링크드리스트에 저장된 데이터가 10000개 일때 9999번째 데이터에 접근하기 위해 9999번째를 이동하지 않아도 된다.

실제로 자바의 LinkedList의 클래스는 링크드리스트라는 이름이 아닌 더블링크드리스트로 구현되어 있다.

| 메서드  | 설명  |
| --- | --- |
| LinkedList() | LinkedList 객체 생성 |
| LinkedList(Collection c) | 주어진 컬렉션을 포함하는 LinkedList 객체를 생성 |
| boolean add(Object o) | 지정된 객체(o)를 LinkedList의 끝에 추가. 저장에 성공하면 true, 실패하면 false |
| void add(int index, Object element) | 지정된 index에 객체를 추가  |
| boolean addAll(Collection c) | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가한다.  |
| boolean addAll(int index, Collection c) | 지정된 위치에 주어진 컬렉션에 포함된 모든 요소를 추가한다.  |
| void clear() | LinkedList안에 모든 요소를 삭제한다.  |
| boolean contains(Object o) | 지정된 객체가 lInkedList에 포함되었는지 알려준다.  |
| boolean containsAll(Collection c) | 지정된 컬렉션의 모든 요소가 포함되었는지 확인한다.  |
| Object get(int index) | index로 객체를 반환한다. index를 통한 get 매소드를 제공하지만 실제로는 순차탐색으로 이루어져있다.  |
| int indexOf(Object o) | 지정된 객체가 저장된 위치를 반환한다.  |
| boolean isEmpty() | LinkedList가 비어있는지 알려준다.  |
| Iterator Iterartor() | Iterator를 반환한다.  |
| int lastIndexOf(Object o) | 지정된 객체가 저장된 위치를 끝부터 검색해 반환한다. |
| ListIterator listIterator() | ListIterator를 반환한다.  |
| ListIterator listIterator(int index) | 지정된 위치에서부터 시작하는 ListIterator를 반환한다.  |
| Object remove(int index) | 지정된 위치의 객체를 LinkedList에서 제거한다.  |
| boolean remove(Object o) | 지정된 객체를 linkedList에서 제거한다.  |
| boolean removeAll(Collection c) | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제  |
| boolean retainAll(Collection c) | 지정된 컬렉션의 모든 요소가 포함되어있는지 확인 |
| Object set(int index, Object element)  | 지정된 위치의 객체를 주어진 객체로 바꾼다.  |
| int size() | LinkedList의 저장된 객체 수를 반환 |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 반환 |
| Object[] toArray() | LinkedList에 저장된 객체를 배열로 반환 |
| Object[] toArray(Object[] a) | LinkedList에 저장된 객체를 주어진 배열에 저장해 반환 |
| Object element() | LinkedList의 첫번째 요소를 반환 |
| boolean offer(Object o) | 지정된 객체(o)를 lInkedList의 끝에 추가.  |
| Object peek() | LinkedList의 첫 번째 요소를 반환 |
| Object poll() | LinkedList의 첫번째 요소를 반환 후 LinkedList에서 제거 |
| Object remove() | LinkedList의 첫번째 요소를 제거  |
| void addFirst(Object o) | LinkedList의 맨 앞에 객체 o 추가  |
| void addLast(Object o) | LinkedList의 맨 끝에 객체 o 추가 |
| Iterator descendingIterator() | 역순으로 조회하기 위한 DescendingIterator를 반환 |
| Object getFirst() | LinkedList의 첫번째 요소를 반환 |
| Object getLast() | LinkedList의 마지막 요소를 반환 |
| boolean offerFirst(Object o) | LinkedList의 맨 앞에 객체 o를 추가  |
| boolean offerLast(Object o) | LinkedList의 맨 끝에 객체 o를 추가  |
| Object peekFirst() | LinkedList의 첫번째 요소를 반환 |
| Object peekLast() | LinkedList의 마지막 요소를 반환 |
| Object pollFirst() | LinkedList의 첫번째 요소를 반환하면서 동시에 제거 |
| Object pollLast() | LinkedList의 마지막 요소를 반환하면서 동시에 제거 |
| Object pop() | removeFirst() 와 동일. 첫번째 요소를 제거  |
| void push(Object o) | addFirst()와 동일. 맨 앞에 객체 o를 추가  |
| Object removeFirst() | LinkedList의 첫번째 요소를 제거  |
| Object removeLast() | LinkedList의 마지막 요소를 제거  |
| boolean removeFirstOccurrence(Object o) | 첫번째로 일치하는 객체를 제거  |
| boolean removeLastOccurrence(Object o) | 마지막으로 일치하는 객체를 제거 |

```java
//링크드 리스트 객체 생성
LinkedList<String> l1 =  new LinkedList<>();
l1.add("A"); // ["A"]

//주어진 컬렉션을 포함하는 LinkedList 객체 생성
LinkedList<String> l2 = new LinkedList<>(l1); //["A"]
```

(참고로 LinkedList는 Queue 인터페이스와 Deque 인터페이스를 구현하도록 변경되었는데, 마지막 22개의 메소드는 Queue 인터페이스와 Deque 인터페이스를 구현하면서 추가된 것이다. )

ArrayList와 Array를 비교한다면

1. **순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.** ArrayList를 처음 생성할때 저장할 데이터의 개수만큼 충분한 초기용량을 확보한상태라면 저장공간이 부족해서 새로운 ArrayList를 만들고 복사하는 일을 발생하지 않기 때문에 순차적으로 데이터를 추가한다면 LinkedList보다 Arraylist가 더 빠르다. 또한 데이터를 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하므로 ArrayList는 마지막 데이터부터 삭제할경우 요소들의 재배치가 필요하지 않기 때문에 상당히 빠른다. 단지 마지막 요소의 값을 null로만 바꾸면 되니까.

2. **중간 데이터를  추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.** 중간 요소를 추가,삭제하는 경우 LInkedList는 각 요소간의 연결만 변경해주면 되므로 처리속도가 빠르다. 하지만 ArrayList는 요소를 재배치해 공간을 확보 또는 빈 공간을 채워야하기때문에 처리속도가 늦다.

```java
public class ArrayListLinkedListTest {
    public static void main(String[] args) {
        //생성
        ArrayList<Object> a1 = new ArrayList<>(1000000);
        LinkedList<Object> l1 = new LinkedList<>();

        //데이터 추가
        add(a1);
        add(l1);

        System.out.println("= 접근시간테스트 ==");
        System.out.println("ArrayList: " + access(a1)); //1
        System.out.println("LinkedList: " + access(l1));//317
    }

    public static void add(List list) {
        for (int i = 0; i < 1000000; i++) {
            list.add(i + "");
        }
    }

    public static long access(List list) {
        long start = System.currentTimeMillis(); //현재시각을 밀리세컨드 단위로 반환
        for (int i = 0; i < 10000; i++) {
            list.get(i);
        }
        long end = System.currentTimeMillis();
        return end - start; //걸리는 시간
    }
}
```

ArrayList와 LinkedList의 접근시간테스트를 해보면 Arraylist가 LinkedList보다 현저히 빠르다. 그 이유는 배열의 경우 만일 인덱스가 n인 요소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결한다

***인덱스가 n인 데이터의 주소 = 배열의 주소 + (n * 데이터 타입의 크기)***

```java
Object[] arr = new Object[5];
//arr[2]의 주소? 
```

Object배열 arr 이 선언되었을 때 **arr[2]**에 저장된 값을 읽으려 한다면 **n은 2** , **모든 참조형 변수의 크기는 4byte** , 생성된 배열의 주소는 ox100이므로 3번째 데이터가 저장되어 있는 주소는 ***ox100 + 2 * 4 = ox108*** 이 된다.

따라서 배열은 메모리상에서 요소들이 연속적으로 존재하기때문에 간단한 계산으로 원하는 요소의 주소를 얻을 수 있지만, LinkedList는 요소들이 불연속적으로 위치하기때문에 처음부터 n 번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다. 그래서 LinkedLists는 데이터의 개수가 길어질수록 데이터를 읽어 오는 시간. 즉 access time이 길어진다는 단점이 있다.

| 컬렉션 | 읽기(접근시간) | 추가/삭제 | 비고 |
| --- | --- | --- | --- |
| ArrayList | 빠르다  | 느리다 | 순차적인 추가,삭제는 더 빠름.  |
| LinkedList | 느리다 | 빠르다 | 데이터가 많을수록 접근성이 떨어짐. |

즉! 데이터의 개수가 변하지 않는 경우라면 ArrayList가 최상의 선택이 되겠고, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이다.


## 1.4 Stack과 Queue

![a](https://github.com/princenim/TIL/assets/59499600/147d1769-c3d7-403e-9633-60cdafdec0da)

**스택**은 마지막에 저장한 데이터를 가장 먼저 꺼내는 **LIFO(Last In First Out)** 의 구조리며, **큐**는 처음에 저장한 데이터를 가장 먼저 꺼내게 되는 **FIFO(First In First Out)** 의 구조이다.

예를 들면 스택은 웹 브라우저의 방문기록 (뒤로가기), 나중에 실행된 것부터 나중에 취소하는 실행 취소와 같은 곳에 활용할 수 있다. 큐는 프린터의 인쇄 대기열같은 우선순위가 같은 작업 예약, 프로세스 관리와 같은 입력 순서대로 처리해야할 필요가 있는 상황에 이용한다.

- Stack 메서드

| 메서드                              | 설명 |
|----------------------------------| --- |
| boolean empty()                  | Stack이 비어있는지 알려준다 .  |
| Object peek()                    | Stack의 맨 위에 저장된 객체를 반환. pop과 달리 Stack에 객체를 꺼내지는 않는다.  |
| Object pop()                     | Stack의 맨 위에 저장된 객체를 꺼낸다. (비었을때는 EmptyStackException이 발생) |
| Object push(Object item)         | Stack에 객체를 저장한다.  |
| int search(Object o)             | Stack에서 주어진 객체를 찾아서 그위치를 반환, 못찾으면 -1을 반환한다. 배열과 달리 위치는 0이 아닌 1부터 시작 |

- Queue 메서드

| 메서드  | 설명 |
| --- | --- |
| boolean add() | 지정된 객체를 Queue에 추가한다.  |
| Object remove() | Queue에 객체를 꺼내 반환. 비어있으면 NoSuchElementException이 발생 |
| Object element() | 삭제없이 요소를 읽어온다. peek()와 달리 Queue가 비었을 때 NoSuchElementException 발생 |
| boolean offer(Object o) | Queue에 객체를 저장. 성공하면 true, 실패하면 false |
| Object poll() | Queue에서 객체를 꺼내서 반환. 비어있으면 null 반환 |
| Object peek() | 삭제없이 요소를 읽어온다. Queue가 비어있으면 null 반환  |

```java
public static void main(String[] args) {
    //stack과 Queue 선언
    Stack<Object> st = new Stack<>();
    Queue<Object> q = new LinkedList<>(); //Queue 인터페이스의 구현체인 LinkedList를 사용

    st.push("A");
    st.push("B");
    st.push("C");
    q.add("A");
    q.add("B");
    q.add("C");

    while (!st.empty()){
        System.out.println(st.pop()); //C, B, A
    }
    while (!q.isEmpty()){
        System.out.println(q.poll()); //A, B, C
    }
}
```

자바에서는 스택을 Stack클래스로 구현하려 제공하고 있지만 큐는 Queue 인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있지 않다. 대신 Queue 인터페이스를 구현한 클래스들이 있어 이 들 중의 하나를 선택해서 사용하면 된다. Queue 의 경우 엄밀히 말하면 List 인터페이스에 포함되어 있지 않다 .

자바에서 LinkedList는 Linst를 구현하기도 하지만 Queue의 Deque 클래스를 구현하기도 한다.

```java
public class LinkedList<E>
    extends AbstractSequentialList<E>
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable { } //이 부분
```

참고로 인터페이스는 설계도, 구현체는 인터페이스를 구현한 클래스라는 뜻이다. (= 구현 클래스 or 실체클래스)

### 스택과 큐의 활용

**스택 : 웹브라우저의 뒤로/ 앞으로 , 수식계산 및 수식괄호검사**

**큐: 최근사용문서 , 인쇄작업 대기목록**

- 웹 브라우저 뒤로/앞으로 예제

```java
public class StackEx1 {

    //두 개의 스택 선언
    public static Stack<String> back = new Stack<>();
    public static Stack<String> forward = new Stack<>();

    public static void main(String[] args) {
        goURL("1.네이트");
        goURL("2.야후");
        goURL("3.네이버");
        goURL("4.다음");

        printStatus();

        goBack();
        System.out.println(" = 뒤로 버튼을 누른 후= ");
        printStatus();

        goBack();
        System.out.println(" = 뒤로 버튼을 누른 후= ");
        printStatus();

        goForward();
        System.out.println(" = 앞으로 버튼을 누른 후= ");
        printStatus();

        goURL("www.hi.com");
        System.out.println(" = 새로운 주소로 이동 후= ");
        printStatus();
    }

    public static void printStatus() {
        System.out.println("back:" + back);
        System.out.println("forward:" + forward);
        System.out.println("현재 화면은 '" + back.peek() + "' 입니다.");
        System.out.println();
    }

    public static void goURL(String url) {
        back.push(url);
        if (!back.isEmpty()) {
            forward.clear();
        }
    }

    public static void goForward() {
        if (!forward.empty()) {
            back.push(forward.pop());
        }
    }

    public static void goBack() {
        if (!back.isEmpty()) {
            forward.push(back.pop());
        }
    }
}
```

- 수식 괄호 체크

```java
public class ExpValidStack {
    public static void main(String[] args) {
        //수식의 괄호의 쌍이 맞는지
        Stack<String> st = new Stack<>();
        String expression = "((2+3) *1) + 3";

        try {
            for (int i = 0; i < expression.length(); i++) {
                char ch = expression.charAt(i);

                if (ch == '(') {
                    st.push(ch + ""); //넣고
                } else if (ch == ')') {
                    st.pop();// 꺼내고
                }
            }

            if (st.isEmpty()) { //비어있으면 괄호가 맞다는 의미니까
                System.out.println("괄호가 일치합니다.");
            } else {
                System.out.println("괄호가 일치하지 않습니다.");
            }

        } catch (EmptyStackException e) { //비어있는데 pop하면 발생하는 에러
            System.out.println("괄호가 일치하지 않습니다.");
        }
    }
}
```

- 유닉스의 `history` 명령어를 queue를 이용해서 구현

```java
public class QueueEx1 {
    static Queue<String> q = new LinkedList<>();
    static final int MAX_SIZE = 5;

    public static void save(String input) {
        //queue에 저장
        if (!"".equals(input)) {
            q.offer(input);
        }
        //queue의 최대 크기를 넘으면 제일 처음 입력된 것을 삭제 - 무조건 5개만 저장가능
        if (q.size() > MAX_SIZE) {
            q.remove();
        }
    }

    public static void main(String[] args) {
        System.out.println("help를 입력하면 도움말을 볼 수 있습니다.");
        while (true) {
            System.out.print(">>");
            try {
                Scanner s = new Scanner(System.in);
                String input = s.nextLine().trim();

                if ("".equals(input)) {
                    continue;
                }

                if (input.equalsIgnoreCase("q")) {
                    System.exit(0); //프로세스 강제 정상종료
                } else if (input.equalsIgnoreCase("help")) {
                    System.out.println("help - 도움말을 보여줍니다.");
                    System.out.println("q 또는 Q - 프로그램을 종료합니다.");
                    System.out.println("history - 최근에 입력한 명령어를 " + MAX_SIZE + "개 보여줍니다.");
                } else if (input.equalsIgnoreCase("history")) {
                    int i = 0;
                    //입력어 저장
                    save(input);
                    //LinkedList의 내용을 보여준다.
                    LinkedList tmp = (LinkedList) q;
                    ListIterator it = tmp.listIterator();

                    while (it.hasNext()) {
                        System.out.println(++i + "." + it.next());
                    }
                } else {
                    save(input);
                    System.out.println(input);
                }

            } catch (Exception e) {
                System.out.println("입력 오류입니다.");
            }
        }
    }
}
```

### PriorityQueue (우선순위큐)

Queue 인터페이스의 구현체(인터페이스를 구현한 클래스)중 하나로 저장한 순서에 관계없이 우선순위가 높은 것부터 꺼내게 된다. 우선순위 queue는 값을 비교해야하므로 null은 저장할 수 없다.  null을 저장하면 `NullPointException`이 발생한다.ㅣ

저장공간으로 배열을 사용하며 각 요소를 힙(heap) 이라는 자료구조의 형태로 저장한다. 힙은 이진트리의 한 종류로가장 큰 값이나 가장 작은 값을 빠르게찾을 수 있다는 특징이 있다.

```java
public class PriorityQueueEx {
    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();

        pq.offer(1);
        pq.offer(3);
        pq.offer(2);
        pq.offer(5);
        pq.offer(4);
        System.out.println(pq); //저장순서 출력 1,3,2,5,4,
        
        //내부적으로 힙 자료구조로 저장
        while (!pq.isEmpty()){
            System.out.println(pq.poll())//출력 1,2,3,4,5
        }
    }
}
```

### Deque (Double- Ended Queue)

Queue의 변형으로, 한쪽 끝으로만 추가/삭제할 수 있는 Queue와 달리 Dequeue(덱 또는 디큐)는 양쪽 끝에 추가/삭제가 가능하다. 구현체로는 ArrayDeqe와 LinkedList가 있다.

<img width="450" alt="c" src="https://github.com/princenim/TIL/assets/59499600/ad945443-da2c-4238-b495-4f08b32e63c6">


덱은 스택과 큐를 하나로 합쳐놓은 것과 같으며 스택으로도 , 큐로도 사용할 수 있다.


## 1.8 HashSet

HashSet은 Set 인터페이스를 구현한 가장 대표적인 컬렉션이며, Set인터페이스의 특징대로 중복된 요소를 저장하지 않는다. 따라서 새로운 요소를 추가할 때는 add, addAll메서드를 사용하는데 만약 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 하면 이 메서드들은 false를 반환해 추가에 실패했다는 것을 알려준다. 따라서 이러한 특징을 이용하면 컬렉션 내의 중복 요소들을 쉽게 제거할수 있다.

ArrayList와 달리 HashSet은 저장순서를 유지하지 않으므로 **저장순서를 유지하고자 한다면 LinkedHashSet을 이용해야한다.**

| 메서드 | 설명 |
| --- | --- |
| HashSet() | 객체 생성 |
| HashSet(Collection c) | 주어진 컬렉션을 포함하는 HashSet 객체 생성 |
| HashSet(int initialCapacity) | 주어진 값을 초기용량으로 하는 HashSet객체 생성 |
| HashSet(int initialCapacity, float loadFactor) | 초기용량과 load factor을 지정하는 생성자 |
| boolean add(Object o) | 새로운 객체를 저장 |
| boolean addAll(Collection c) | 주어진 컬렉션에 저장된 모든 객체들을 추가 (합집합) |
| void clear() | 저장된 모든 객체를 삭제 |
| Object clone() | HashSet을 복제해서 반환 (얕은 복사) |
| boolean contains(Object o) | 지정된 객체를 포함되고 있는지 알려준다.  |
| boolean containsAll(Collection c) | 주어진 컬렉션에 저장된 모든 객체들을 포함하고 있는지 알려준다  |
| boolean isEmpty() | HashSet이 비어있는지 알려준다.  |
| Iterator iterator() | Iterator이 비어있는지 알려준다.  |
| boolean remove(Object o) | 지정된 객체를 HashSet에서 삭제  |
| boolean removeAll(Collection c) | 주어진 컬렉션에 저장된 모든객체와 동일한 것들을 HashSet에서 삭제(차집합) |
| boolean retainAll(Collection c) | 주어진 컬렉션에 저장된 모든객체와 동일한 것만 남기고 HashSet에서 삭제(교집합) |
| int size() | 저장된 객체의 개수를 반환 |
| Object[] toArray() | 저장된 객체들을 객체배열의 형태로 반환 |
| Object[] toArray(Object[] a) | 저장된 객체들을 주어진 객체배열(a)에 담는다. |
- load factor : 컬렉션 클래스에 저장공간이 가득 차기 전에 미리 용량을 확보하기 위한 것으로 만약 0.8로 지정하면, 저장공간의 80%가 채워졌을때 용량이 2배로 늘어난다. 기본값은 0.75 즉 75%이다.

```java
//객체 생성
HashSet<Integer> hs1 = new HashSet<>();
hs1.add(1);

HashSet<Integer> hs2 = new HashSet<>(hs1); //주어진 컬렉션을 포함하는 객체 생성
HashSet<Integer> hs3 = new HashSet<>(10, 0.8F);//로드팩터가 0.8

System.out.println(hs2.contains(2));

System.out.println(hs2.addAll(hs1)); //[1] 에 [1] 추가해서 false
System.out.println(hs2); //그대로 [1]

hs2.remove(1); //객체 삭제
hs2.removeAll(hs1);//컬렉션 삭제
```

- **HastSet 예제 1** : 중복 저장 유무 확인

```java

public static void main(String[] args) {
	  Object[] objArr = {"1", 1, "2","2","2","4"};
	  HashSet<Object> hs = new HashSet<>();
	
	  //asList는 배열을 List로 변환
	  //후에 HashSet에 저장
	  hs.addAll(Arrays.asList(objArr));
	  System.out.println(hs); //1,1,2,4,
}
```

- **HastSet 예제 2** :  중복된 값은 저장되지 않는 HashSet을 이용한 로또번호 만들기

```java
public static void main(String[] args) {
      Set<Integer> set  = new HashSet<>();

      for(int i =0; i < 6; i++){
          int num = (int)(Math.random() *45);//0.0 ~ 0.1사이의 랜덤 숫자
          set.add(num);
      }

      
      List<Integer> list =  new LinkedList<>(set); //LinkedList(Collection c)
    Collections.sort(list);//크기순으로 정렬
	    System.out.println(list);
}
```

- **HastSet 예제 3** : 빙고 만들기 - HashSet은 저장된 순서를 보장하지 않고 자체적인 저장방식에 따라 순서가 결정되기 때문에 몇번 실행을 하면 같은 숫자가 비슷한 위치에 나온다 . 따라서 HashSet보다 저장순서를 유지하는 LinkedHashSet이 더 나은 선택이다.

```java
public static void main(String[] args) {
        //HashSet<Object> set1  = new HashSet<>(); //자체적인 저장방식에 따라 순서가 결정
        HashSet<Integer> set1 = new LinkedHashSet<>(); //
        int[][] board = new int[5][5]; //2차원 배열

        for (int i = 0; set1.size() < 25; i++) { //25번 add
            set1.add((int) (Math.random() * 50) + 1);//1을 더하는 이유는 1부터 시작하기 위해서
        }

        Iterator it = set1.iterator();

        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                board[i][j] = (int) it.next(); //next의 반환값은 Object
                System.out.print((board[i][j] < 10 ? "  " : " ") + board[i][j]);
            }
            System.out.println();
        }

//        for(int[] tmp: board){
//            System.out.println(Arrays.toString(tmp));
//        }
    
```

- **HastSet 예제 4** : name과 age가 같으면 같은 사람으로 인식하기

```java
public class HashSetEx3 {
    public static void main(String[] args) {
        Set<Object> set = new HashSet<>();
        set.add("abe");
        set.add("abe");
        set.add(new Person("Lucy", 10));
        set.add(new Person("Lucy", 10));
        System.out.println(set); //[abe, Lucy:10, Lucy:10]
    }
}

class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() { //toString을 재정의
        return name + ":" + age; //따라서 직접 호출하지 않아도 문자열 출력시,자동으로 호출된다.

    }
}
```

위의 예제의 결과를 보면 Hashset인데도 불구하고 결과는 **[abe, Lucy:10, Lucy:10]** 로,name과 age의 값이 같음에도 불구하고 서로 다른 것으로 인식해 2번 출력되었다. 그렇다면 두 인스턴스를 같은것으로 인식하게 하려면 어떻게 해야할까?

- HastSet 예제 4 : name과 age가 같으면 같은 사람으로 인식하기 2

```java
public class HashSetEx4 {
    public static void main(String[] args) {
        Set<Object> set = new HashSet<>();
        set.add("abe");
        set.add("abe");
        Person2 p1 = new Person2("Lucy", 10);
        Person2 p2 = new Person2("Lucy", 20);

        System.out.println(System.identityHashCode(p1));
        System.out.println(System.identityHashCode(p2));
        System.out.println("객체 비교#: " + (p1 == p2)); //false ,new 연산자로 만들면 주소값이 다르며, ==는 객체의 주소값을 비교한다.

        System.out.println(System.identityHashCode(p1.age));
        System.out.println(System.identityHashCode(p2.age));//10,20으로 값이 다르기때문에 인스턴스변수의 주소값이 디름.  10,10이면 값게 나옴.
        System.out.println("인스턴스 변수 주소비교#: " + (p1.age == p2.age)); //false

        set.add(p1);
        set.add(p2);
        System.out.println(set); //[abe, Lucy:10, Lucy:10]
    }
}

class Person2 {
    String name;
    Integer age;

    //생성자
    Person2(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String toString() { //toString을 재정의
        return name + ":" + age; //따라서 직접 호출하지 않아도 문자열 출력시,자동으로 호출
    }

    //name과 age가 같으면 서로 true를 반환
    @Override
    public boolean equals(Object obj) {
        System.out.println(obj); //p2더할때 obj는 p2
        if (obj instanceof Person2) { //자식관계확인
            Person2 tmp = (Person2) obj;
            return name.equals(tmp.name) && age == tmp.age; //String이므로 주소가아닌 문자열 비교
        }
        return false;
    }

    public int hashCode() {
        return (name + age).hashCode();//해쉬코드란 각 객체의 주소값을 변환해 생성한 객체의 고유한 정수값
    }
}
```

HashSet의 add()메서드는 새로운 요소를 추가하기전에 기존에 저장된 요소와 같은 것인지 판별하기 위해 추가하려는 요소의 equals()와 hashCode()를 호출하기때문에  메서드를 목적에 맞게 오버라이딩해야한다.
그래서 String 클래스에서 같은 내용의 문자열에 대한 equals() 호출결과가 true인 것과 같이 Person 클래스에서도 두 인스턴스의 name, age가 서 로 같으면 true를 반환하도록 equals()를 오버라이딩했다. 그리고
hashCode()는 String 클래스의 hashCode()를 이용해서 구현했다.

### + System.identityHashCode()

참고로 `System.identityHashCode()`과 `hashCode()` 모두 객체의 고유한 값을 리턴한다는 점에서 같다. 하지만 차이가 있는데 `hashCode()`는 하위 클래스에서 오버라이드가 가능하기때문에 객체마다 유일한 값을 갖고있지않다. 예를들어 String의 hashcode가 갖다면 객체주소는 달라도 문자열이 동일하다는 것을 의미한다. 하지만`System.identityHashCode()`는 오버라이드가 안되며 객체의 고유한 hashcode를 리턴한다. 따라서 `System.identityHashCode()` 를 사용하는 것이 좋다
- HastSet 예제 5 : 합집합, 교집합, 차집합

```java
public static void main(String[] args) {
    HashSet<Object> setA = new HashSet<>();
    HashSet<Object> setB = new HashSet<>();
    HashSet<Object> setHap = new HashSet<>(); //합집합
    HashSet<Object> setKyo = new HashSet<>();// 교집합
    HashSet<Object> setCha = new HashSet<>(); //차집합

    setA.add("1");
    setA.add("2");
    setA.add("3");
    setA.add("4");
    setA.add("5");
    System.out.println("A = " + setA);

    setB.add("4");
    setB.add("5");
    setB.add("6");
    setB.add("7");
    setB.add("8");
    System.out.println("B = " + setB);

    //교집합
    Iterator it = setB.iterator();
    while (it.hasNext()) {
        Object tmp = it.next();
        if (setA.contains(tmp)) {
            setKyo.add(tmp);
        }
    }

    //차집합
    it = setA.iterator();
    while (it.hasNext()) {
        Object tmp = it.next();
        if (!setB.contains(tmp)) {
            setCha.add(tmp);
        }
    }

    //합집합
    it = setA.iterator();
    while (it.hasNext()) {
        setHap.add(it.next());
    }
    it = setB.iterator();
    while (it.hasNext()) {
        setHap.add(it.next());
    }
    System.out.println(setHap);
    System.out.println(setKyo);
	  System.out.println(setCha);
}
```




## 1.9 TreeSet

`TreeSet`은 **이진검색트리(Binary search tree)라는 자료구조의 형태로 데이터를 저장하는 컬렉션 클래스이다.** 이진 검색 트리는 정렬,검색, 범위검색(range search)에 높은 성능을 보이는 자료구조이며, TreeSet이는 이진 검색 트리의 성능을 향상시킨 **레드-블랙 트리(Red Black Tree)**로 구현되어 있다.

그리고 **Set인터페이스를 구현했으므로 중복된 데이터의 저장을 허용하지 않으며 정렬된 위치에 저장하므로, 저장순서를 유지하지도 않는다.**

**이진트리(Binary Tree)**는 링크드 리스트처럼 여러 개의 노드가 서로 연결된 구조로, 각 노드에 최대 2개의 노드를 연결할 수 있으며 루트라고 불리는 하나의 노드에서부터 시작해 계속 확장해 나갈 수 있다. 위 아래로 연결된 두 노드를 부모-자식관계에 있다고 하면 위의 노드를 부모 노드, 아래의 노드를 자식노드라고 한다.

<img width="484" alt="binary tree" src="https://github.com/princenim/TIL/assets/59499600/e836ce1e-d4ec-4840-82da-90e5904fd786">

이진 트리의 노드를 코드로 표현하면 다음과 같다. 데이터를 저장하기 위한 Object 타입의 참조변수 하나와 두개의 노드를 참조하기 위한 두 개의 참조변수를 선언한다.

```java
class TreeNode{
    TreeNode left; //왼쪽 자식 노드 
    Object element;  //객체를 저장하기 위한 참조변수 (값이 들어가 있는 주소를 가지고 있는 변수!)
    TreeNode right; //오른쪽 자식 노드 
}
//참조변수? 실제 값을 가진 변수가 아니라 값이 들어가 있는 주소를 가지고 있는 변수를 말한다. 
```

더 나아가 **이진 검색 트리(Binary search tree)** 는 부모 노드의 왼쪽에는 부모노드의 값보다 작은 값의 자식노드를 오른쪽에는 큰 값의 자식노드를 저장하는 이진트리이다.

![이진검색트리](https://github.com/princenim/TIL/assets/59499600/04fb1513-eccd-44c7-a11a-61ce3de806cc)

<img width="384" alt="이진" src="https://github.com/princenim/TIL/assets/59499600/4b8c6187-c91f-4a11-b503-cf43aa7cf812">

예를들어 이진 검색 트리에 7,4,9,1,5의 순서로 값을 저장한다고 가정하면 밑의 그림과 같은 저장과정을 거친다.

![과정](https://github.com/princenim/TIL/assets/59499600/dc8a7da7-0c4d-411f-b018-c436964d6218)

1. 먼저 저장되는 7은 루트가 된다.
2. 두번째 4는 루트와 값을 비교해 트리를 따라 왼쪽에 저장한다.
3. 세번째 9도 루트와 비교해 오른쪽에 저장한다.
4. 네번째 1도 루트와 비교 그리고 밑의 노드와 비교해 더 작은 값이기 때문에 왼쪽에 저장한다.

참고로 컴퓨터는 알아서 값을 비교하지 못하는데 TreeSet에 저장되는 객체가 Comparable을 구현하던가 아니면, TreeSet에게 Comparator를 제공해서 두객체를 비교할 방법을 알려줘야 한다 그렇지 않으면 TreeSet에 객체를 저장할 떄 예외가 발생한다.

따라서 왼쪽 마지막 값에서부터 오른쪽 값까지 값을 ‘왼쪽 → 부모 → 오른쪽 노드’순으로 읽으면 오름차순으로 정렬된 순서를 얻을 수 있다. 이처럼 TreeSet은 정렬된 상태를 유지하기 때문에 단일 값 검색과 범위검색 예를 들면 3과 7 사이의 범위에 검색이 매우 빠르다.

저장된 값의 개수에 비례해서 검색시간이 증가하긴 하지만 값의 개수가 10배 증가해도 특정 값을 찾는데 필요한 비교횟수가 3~4번만 증가할 정도로 **검색효율이 뛰어난 자료구조이다.**

**트리는 데이터를 순차적으로 저장하는 것이 아니라 저장위치를 찾아서 저장해야하고, 삭제하는 경우 트리의 일부를 재구성해야하므로 링크드 리스트보다 데이터의 추가/삭제 시간은 더 걸린다. 대신 배열이나 링크드 리스트에 비해 검색과 정렬기능이 더 뛰어나다.**

**이진검색트리(Binary search tree)**

- 모든 노드는 최대 두개의 자식 노드를 가질 수 있다.
- 왼쪽 자식노드의 값은 부모노드의 값보다 작고 오른쪽자식노드의 값은 부모노드의 값보다 커야한다.
- 노드의 추가/삭제에 시간이 걸린다.(순차적으로 저장하지 않으므로 )
- 검색과 정렬에 유리하다.
- 중복된 값을 저장하지 못한다.


| 생성자 또는 메서드                                                                                                                       | 설명                                                                   |
|----------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------|
| TreeSet()                                                                                                                        | 기본 생성자                                                               |
| TreeSet(Collection c)                                                                                                            | 주어진 컬렉션을 저장하는 TreeSet 생성                                             |
| TreeSet(Comparator comp)                                                                                                         | 주어진 정렬조건으로 정렬하는 TreeSet 생성                                           |
| TreeSet(SortedSet s)                                                                                                             | 주어진 SortedSet을 구현한 컬렉션을 저장하는 TreeSet생성 (SortedSet은 원소들이 정렬되어 있는 set) |
| boolean add(Object o), boolean addAll(Collection c)                                                                              | 지정된 객체 또는 Collection의 객체들을 Collection에 추가                            |
| Object ceiling(Object o)                                                                                                         | 지정된 객체와 같은 객체를 반환, 없으면 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null       |
| void clear()                                                                                                                     | 저장된 모든 객체를 삭제                                                        |
| Object clone()                                                                                                                   | TreeSet을 복제해 반환                                                      |
| Comparator comparator()                                                                                                          | TreeSet의 정렬기준을 반환 (comparator)                                       |
| boolean contains(Object o),                                                                     boolean containAll(Collection c) | 객체 또는 Collection의 객체들의 포함되어 있는지 확인                                   |
| NavigableSet descendingSet()                                                                                                     | TreeSet에 저장된 요소들을 역순으로 정렬해 반환                                        |
| Object first()                                                                                                                   | 정렬된 순서에서 첫번째 객체를 반환                                                  |
| Object floor(Object o)                                                                                                           | 지정된 객체와 같은 객체를 반환. 없으면 작은 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null      |
| SortedSet headSet(Object toElement)                                                                                              | 지정된 객체보다 작은 값의 객체들을 반환                                               |
| NavigableSet headSet(Object toElement, boolean inclusive)                                                                        | 지정된 객체보다 작은 값의 객체들을 반환 Inclusive가 true면 같은 값의 객체도 포함                 |
| Object higher(Object o)                                                                                                          | 지정된 객체보다 큰 값을 가진 객체 중 제일 가까운 값의 객체를 반환. 없으면 null                     |
| boolean isEmpty()                                                                                                                | TreeSet이 비어있는지 확인                                                    |
| Iterator iterator()                                                                                                              | TreeSet 의 Iterator를 반환                                               |
| Object last()                                                                                                                    | 정렬된 순서에서 마지막 객체를 반환                                                  |
| Object lower(Object o)                                                                                                           | 지정된 객체보다 작은 값을 가진 객체중 제일 가까운 값의 객체를 반환. 없으면 null                     |
| Object pollFirst()                                                                                                               | TreeSet의 첫번째 요소(제일 작은 값의 객체)를 반환                                     |
| Object pollLast()                                                                                                                | TreeSet의 마지막 번째 요소(제일 큰 값의 객체)를 반환                                   |
| boolean remove(Object o)                                                                                                         | 지정된 객체를 삭제                                                           |
| boolean retainAll(Collection c)                                                                                                  | 주어진 컬렉션과 공통된 요소만을 남기고 삭제 (교집합)                                       |
| int size()                                                                                                                       | 저장된 객체의 개수를 반환한다.                                                    |
| Spliterator spliterator()                                                                                                        | TreeSet의 spliterator을 반환                                             |
| SortedSet subSet(Object fromElement, Object toElement)                                                                           | 범위검색(from~ to)의 결과를 반환한다. (끝 범위는 포함되지 않음. )                          |
| NavigableSet<E> subSet(E fromElement, boolean FromInclusive, E toElement, boolean toInclusive)                                   | 범위 검색의 결과를 반환한다. (True면 시작값또는 끝값이 포함된다.)                             |
| SortedSet tailSet(Object fromElement)                                                                                            | 지정된 객체보다 큰 값의 객체들을 반환                                                |
| Object[] toArray()                                                                                                               | 저장된 객체를 객체배열로 반환                                                     |
| Object[] toArray(Object[] a)                                                                                                     | 저장된 객체를 주어진 객체배열에 저장해 반환                                             |

```java
TreeSet<Integer> ts1 = new TreeSet<>(); //객체 생성
ts1.add(1);
ts1.add(2);

TreeSet<Integer> ts2 = new TreeSet<>(ts1);//주어진 컬렉션을 저장하는 TreeSet생성
System.out.println(ts1); //[1,2]
System.out.println(ts2); //[1,2]

TreeSet<Integer> ts3 = new TreeSet<>(Collections.reverseOrder()); //내림차순으로 정렬로 생성
ts3.add(1); 
ts3.add(2);
System.out.println(ts3); //[2,1]

System.out.println(ts3.ceiling(1)); //같은 객체 반환
System.out.println(ts3.comparator()); //정렬기준 반환
System.out.println(ts1.comparator());

System.out.println(ts3.descendingSet());//기존 정렬에서 역순으로 정렬해서 반환
System.out.println(ts1.descendingSet());
```