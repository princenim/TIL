# 1. 컬렉션 프레임워크(Collections Framework)

컬렉션 프레임워크이란 데이터를 저장하는 클래스들을 표준화한 설계를 말한다. 컬렉션은 데이터 그룹을 프레임워크는 표준회된 프로그래밍 방식을 의미한다.

컬렉션 프레임워크는 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 덜어주고, 인터페이스와 다양한 객체지향적 설계를 통해 표준화되어있기때문에 사용법을 익히기에도 편리하다.

## 1.1 컬렉션 프레임워크의 핵심 인터페이스

컬렉션 프레임워크에서는 컬렉션 데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의했다.

![img](https://github.com/princenim/TIL/assets/59499600/54ffb144-6149-4797-b19e-d1ae6b2a6c79)

List, Set을 구현한 컬렉션 클래스들은 서로 많은 공통점이 있어 공통된 부분을 뽑아 다시 Collection 프레임워크로 정의할 수 있었지만 Map 인터페이스는 이들과는 다르게 다른 형태로 다루기 때문에 같은 상속도계층도에 포함되지 못했다. 이러한 설계는 객체지향언어의 장점을 극명히 보여준다. 따라서 프로그래밍 실력을 어느정도 갖추게 되었을 때 컬렉션 프레임워크의 실제 소스를 분석해보면 객체지향적인 설계능력을 향상시키는데 많은 도움이 될 것이다.

- `List` : 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. - ArrayList, LinkedList, Vector
    - e.g. 대기자 명단
- `Set` : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.  - HashSet, TreeSet
    - e.g. 양의 정수집합, 소수의 집합
- `Map` : 키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않으나, 값은 중복을 허용한다. - HashMap, TreeMap, HashTable, Properites
    - e.g. 우편번호, 지역번호


컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set , Map 중 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다. 그러나 Vector, Stack , Hashtable, Properties 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이므로 컬렉션 프레임워크 명명법을 따르지 않는다.

따라서 Vector, Hashtable 과 같은 기존 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨주었지만 가능하면 사용하지 않는 것이 좋다. 대신 ArrayList와 Hashmap을 사용하다.

### List 인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다. ArrayList, LinkedList , Stack

List 인터페이스에 정의된 메서드 목록

| 메서드                                                                          | 설명 |
|------------------------------------------------------------------------------| --- |
| void add(int index, Object element) ,boolean addAll(int index, Collection c) | 지정된 index에 객체(element) 또는 객체들(Collection )을 추가한다.  |
| Object get(int index)                                                        | index에 있는 객체를 반환한다.  |
| int indexOf(Object o)                                                        | 지정된 객체의 index를 반환한다. (List 첫번째 요소부터 순방향으로) |
| int lastIndexOf(Object o)                                                    | 지정된 객체의 index를 반환한다. (List 마지막 요소부터 순방향으로) |
| ListIterator listItertor(), ListIterator listItertor(int index)                                          | List의 객체에 접근할 수 있는 ListIterator 를 반환한다.  |
| Object remove(int index)                                                     | index에 있는 객체를 삭제하고 삭제된 객체를 반환한다.  |
| Object set(int index, Object element)                                        | index에 객체를 저장한다.  |
| void sort(Comparator c)                                                      | 지정된 비교자로 부터 List를 정렬한다. (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(int fromIndex, int toIndex)                                     | 지정된 범위에 있는 객체를 반환한다. from ~ to |

```java
//ListIterator 
LinkedList<String> list = new LinkedList<String>();
list.add("A");
list.add("B");
Iterator<String> iter = list.iterator();

while(iter.hasNext()) { //has.Next는 읽을 다음 여부가 있는지 반환
    System.out.println(iter.next()); //next()는 다음요소를 읽어온다.  
}
```

### Set 인터페이스

중복을 허용하지 않고 저장순서가 유지 되지 않는 컬렉션 클래스를 구현할때 사용한다. HashSet, TreeSet.

### Map 인터페이스

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용된다. 키는 중복될수 없고, 값은 중복을 허용한다.기존에 저장된 데이터와 중복된 키에 값을 저장하면 기존의 값은 없어지고, 마지막에 저장된 값이 남겨진다. Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap

| 메서드  | 설명  |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다.  |
| boolean containsKey(Object Key) | 지정된 key 객체와 일치하는 Map의 Key 객체가 있는지 확인한다.  |
| boolean containsKey(Object Value) | 지정된 value 객체와 일치하는 Map의 value객체가 있는지 확인한다.  |
| Set entrySet() | Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.  |
| boolean equals(Object o) | 동일한 Map 인지 비교한다.  |
| Object get(Object key ) | 지정한 Key 객체에 대응하는 value객체를 찾아서 반환한다.  |
| int hashCode() | 해쉬코드를 반환한다. 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값을 말한다.  |
| boolean isEmpty() | Map이 비어있는지 확인한다.  |
| Set keySet() | Map에 저장된 모든 Key객체를 반환한다.  |

참고로 Object는 자바가 만들어놓은 API 중에서 최상위 클래스이다. 모든 사용자가 만든 클래스는 Object로부터 상속받는다. 따라서 모든 클래스는 Object 클래스릐 메서드를 사용할 수 있다.
객체 또는 Object는 클래스에서 정의한 것을 토대로 메모리에 할당된 것을 말한다. 따라서 메모리가 할당되기 전까지 객체는 존재하지 않는다. 객체 지향 프로그래밍에서 객체는 클래스의 인스턴스다 .

keySet() 의 반환타입은 Set 이며, value() 반환타입은 Collection 이라는 것에 주목하자. Map 인터페이스에서 값은 중복을 허용하기 때문에 Collection 타입으로, key는 중복을 허용하지 않기 때문에 set 타입으로 반환한다.

### Map.Entry 인터페이스

Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것도 가능하다.
Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해놓았다. 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map 인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스를 함께 구현해야한다.

## 1.2 ArrayList

ArrayList는 List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고, 중복을 허용한다는 특징을 갖는다. ArrayList는 Object 배열을 이용해 데이터를 순차적으로 저장한다. 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장한다.

| 메서드  | 설명                                                                                                    |
| --- |-------------------------------------------------------------------------------------------------------|
| ArrayList() | 크기가 10인 ArrayList를 생성                                                                                 |
| ArrayList(Collection c) | 주어진 컬렉션이 저장된 ArrayList를 생성                                                                            |
| ArrayList(int initialCapacity) | 지정된 컬렉션이 저장된 ArrayList를 생성                                                                            |
| boolean add(Object o) | ArrayList에 마지막에 객체를 추가. 성공하면 true                                                                     |
| void add(int index, Object element) | 지정된 index에 객체를 저장                                                                                     |
| boolean addAll(Collection c) | 주어진 컬렉션의 모든 객체를 저장, 즉 붙이기                                                                             |
| void clear() | ArrayList를 완전히 비운다.                                                                                   |
| Object clone() | ArrayList를 복제한다.                                                                                      |
| boolean contains(Object o) | 지정된 객체(o)가 ArrayList에 포함되어있는지 확인                                                                      |
| void ensureCapacity(int minCapacity) | ArrayList의 용량이 최소한 minCapacity에 포함되어 있는지 확인                                                           |
| Object get(int index) | index에 저장된 객체를 반환                                                                                     |
| int indexOf(object o) | 지정된 객체가 저장된 위치를 찾아 반환                                                                                 |
| boolean isEmpty() | ArrayList가 비어있는지 확인                                                                                   |
| Iterator iterator() | ArrayList의 Iterator객체를 반환                                                                             |
| int lastIndexOf(Object o) | 객체 o가 저장된 위치를 역방향으로 검색해서 반환                                                                           |
| ListIterator listIterator() | ArrayList의 ListIterator 반환                                                                            |
| ListIterator listIterator(int index) | ArrayList의 지정된 위치부터 시작하는 ListIterator 반환                                                              |
| Object remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean removeAll(Collection c) | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거                                                               |
| boolean retainAll(Collection c) | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만 남기고 다 삭제                                                       |
| Object set(int index, Object elemet) | 주어진 객체를 지정된 index에 저장                                                                                 |
| int size() | ArrayList에 저장된 객체의 개수 반환                                                                              |
| void sort(Comparator c) | 지정된 정렬기준으로 ArrayList 정렬  (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(intfromIndex, int toIndex) | fromIndex 부터 toIndex까지에 저장된 객체를 반환                                                                    |
| Object[] toArray() | ArrayList에 저장된 모든 객체들을 객체배열로 반환                                                                       |
| Object[] toArray(Object[] a) | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환                                                                  |
| void trimToSize() | 용량을 크기에 맞게 줄인다. 즉 빈 공간을 없앤다.                                                                          |

```java
//ArrayList 선언 
ArrayList<String> a1 = new ArrayList<String>(); //타입지정해서 선언,기본 capacity는 10
a1.add("A"); //ArrayList 마지막에 객체 추가
a1.add("B");
ArrayList<String> a2= new ArrayList<String>(50); //초기 capacity를 50으로
a2.add("C");
ArrayList<String> a3= new ArrayList<String>(a1); //주어진 Collection을 초기값으로 생성

//붙이기 addAll
System.out.println(a2.addAll(a3)); //a2 +a3 -> true
System.out.println(a2); //[C, A, B]

//복제 clone
Object a4 = a2.clone();
System.out.println(a4); //[C, A, B]

//컬렉션에 저장된 것과 동일한 객체들을
a2.removeAll(a3); // [C, A, B] - [A,B] = [C]
System.out.println(a2);
```

예제 11-2) 긴 문자열 데이터를 원하는 길이로 잘라서 ArrayList에 담은 다음 출력

```java
public static void main(String[] args) {
    final int LIMIT = 10; //자르고자 하는 글자 개수
    String source = "0123456789abcdefghijABCDEFGHIJ!@#$%^&*()ZZZ";
    int length = source.length();

    //초기 용량이 14인 리스트
    ArrayList<String> list = new ArrayList<>(length / LIMIT + 10); //여유있게 크기 잡기 48/10 + 10 = 14

    for (int i = 0; i < length; i += LIMIT) { //i = 0,10, 20, 30,40
        if (i + LIMIT < length) {
            //add는 ArrayList 마지막에 객체 추가
            list.add(source.substring(i, i + LIMIT));
        } else {
            list.add(source.substring(i));
        }
    }
    System.out.println(list);
}
```

### + Array와 ArrayList의 차이

Array와 ArrayLIst는 모든 것이 비슷하나, 가장 큰 차이점은 길이를 조정할 수 있는가 없는가이다.

자바에서 Array는 **고정길이**이다. 초기화시 배열의 크기를 지정한다. 또한 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어줘야한다.

하지만 ArrayList는 List컬렉션 인터페이스의 한 종류로 **가변길이**이다.  즉 동적으로 사이즈가 늘어난다. 하지만 내부적으로 Array로 구성되어 있다. ArrayList는 디폴트로 10개의 공간을 가진 배열로 시작한다. 따라서 기존 사이즈 이상으로  add()함수를 이용해 추가하려고하면 기존 배열 크기의 1.5배(기존용량 + 기존용량/2)로 resize해 새로운 배열을 만들어서 기존배열을 copy한다. 이런 원리로 ArrayList가 동적으로 크기가 늘어날 수 있는 것이다.


