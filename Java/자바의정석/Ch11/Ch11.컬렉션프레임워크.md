# 1. 컬렉션 프레임워크(Collections Framework)

컬렉션 프레임워크이란 데이터를 저장하는 클래스들을 표준화한 설계를 말한다. 컬렉션은 데이터 그룹을 프레임워크는 표준회된 프로그래밍 방식을 의미한다.

컬렉션 프레임워크는 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 덜어주고, 인터페이스와 다양한 객체지향적 설계를 통해 표준화되어있기때문에 사용법을 익히기에도 편리하다.

## 1.1 컬렉션 프레임워크의 핵심 인터페이스

컬렉션 프레임워크에서는 컬렉션 데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의했다.

![img](https://github.com/princenim/TIL/assets/59499600/54ffb144-6149-4797-b19e-d1ae6b2a6c79)

List, Set을 구현한 컬렉션 클래스들은 서로 많은 공통점이 있어 공통된 부분을 뽑아 다시 Collection 프레임워크로 정의할 수 있었지만 Map 인터페이스는 이들과는 다르게 다른 형태로 다루기 때문에 같은 상속도계층도에 포함되지 못했다. 이러한 설계는 객체지향언어의 장점을 극명히 보여준다. 따라서 프로그래밍 실력을 어느정도 갖추게 되었을 때 컬렉션 프레임워크의 실제 소스를 분석해보면 객체지향적인 설계능력을 향상시키는데 많은 도움이 될 것이다.

- `List` : 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. - ArrayList, LinkedList, Vector
    - e.g. 대기자 명단
- `Set` : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.  - HashSet, TreeSet
    - e.g. 양의 정수집합, 소수의 집합
- `Map` : 키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않으나, 값은 중복을 허용한다. - HashMap, TreeMap, HashTable, Properites
    - e.g. 우편번호, 지역번호


컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set , Map 중 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다. 그러나 Vector, Stack , Hashtable, Properties 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이므로 컬렉션 프레임워크 명명법을 따르지 않는다.

따라서 Vector, Hashtable 과 같은 기존 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨주었지만 가능하면 사용하지 않는 것이 좋다. 대신 ArrayList와 Hashmap을 사용하다.

### List 인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다. ArrayList, LinkedList , Stack

List 인터페이스에 정의된 메서드 목록

| 메서드                                                                          | 설명 |
|------------------------------------------------------------------------------| --- |
| void add(int index, Object element) ,boolean addAll(int index, Collection c) | 지정된 index에 객체(element) 또는 객체들(Collection )을 추가한다.  |
| Object get(int index)                                                        | index에 있는 객체를 반환한다.  |
| int indexOf(Object o)                                                        | 지정된 객체의 index를 반환한다. (List 첫번째 요소부터 순방향으로) |
| int lastIndexOf(Object o)                                                    | 지정된 객체의 index를 반환한다. (List 마지막 요소부터 순방향으로) |
| ListIterator listItertor(), ListIterator listItertor(int index)                                          | List의 객체에 접근할 수 있는 ListIterator 를 반환한다.  |
| Object remove(int index)                                                     | index에 있는 객체를 삭제하고 삭제된 객체를 반환한다.  |
| Object set(int index, Object element)                                        | index에 객체를 저장한다.  |
| void sort(Comparator c)                                                      | 지정된 비교자로 부터 List를 정렬한다. (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(int fromIndex, int toIndex)                                     | 지정된 범위에 있는 객체를 반환한다. from ~ to |

```java
//ListIterator 
LinkedList<String> list = new LinkedList<String>();
list.add("A");
list.add("B");
Iterator<String> iter = list.iterator();

while(iter.hasNext()) { //has.Next는 읽을 다음 여부가 있는지 반환
    System.out.println(iter.next()); //next()는 다음요소를 읽어온다.  
}
```

### Set 인터페이스

중복을 허용하지 않고 저장순서가 유지 되지 않는 컬렉션 클래스를 구현할때 사용한다. HashSet, TreeSet.

### Map 인터페이스

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용된다. 키는 중복될수 없고, 값은 중복을 허용한다.기존에 저장된 데이터와 중복된 키에 값을 저장하면 기존의 값은 없어지고, 마지막에 저장된 값이 남겨진다. Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap

| 메서드  | 설명  |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다.  |
| boolean containsKey(Object Key) | 지정된 key 객체와 일치하는 Map의 Key 객체가 있는지 확인한다.  |
| boolean containsKey(Object Value) | 지정된 value 객체와 일치하는 Map의 value객체가 있는지 확인한다.  |
| Set entrySet() | Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.  |
| boolean equals(Object o) | 동일한 Map 인지 비교한다.  |
| Object get(Object key ) | 지정한 Key 객체에 대응하는 value객체를 찾아서 반환한다.  |
| int hashCode() | 해쉬코드를 반환한다. 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값을 말한다.  |
| boolean isEmpty() | Map이 비어있는지 확인한다.  |
| Set keySet() | Map에 저장된 모든 Key객체를 반환한다.  |

참고로 Object는 자바가 만들어놓은 API 중에서 최상위 클래스이다. 모든 사용자가 만든 클래스는 Object로부터 상속받는다. 따라서 모든 클래스는 Object 클래스릐 메서드를 사용할 수 있다.

객체 또는 Object는 클래스에서 정의한 것을 토대로 메모리에 할당된 것을 말한다. 따라서 메모리가 할당되기 전까지 객체는 존재하지 않는다. 객체 지향 프로그래밍에서 객체는 클래스의 인스턴스다 .