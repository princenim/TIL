# 1. 컬렉션 프레임워크(Collections Framework)

컬렉션 프레임워크이란 데이터를 저장하는 클래스들을 표준화한 설계를 말한다. 컬렉션은 데이터 그룹을 프레임워크는 표준회된 프로그래밍 방식을 의미한다.

컬렉션 프레임워크는 다수의 데이터를 다루는데 필요한 다양하고 풍부한 클래스들을 제공하기 때문에 프로그래머의 짐을 덜어주고, 인터페이스와 다양한 객체지향적 설계를 통해 표준화되어있기때문에 사용법을 익히기에도 편리하다.

## 1.1 컬렉션 프레임워크의 핵심 인터페이스

컬렉션 프레임워크에서는 컬렉션 데이터 그룹을 크게 3가지 타입이 존재한다고 인식하고 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이스를 정의하였다. 그리고 인터페이스 List와 Set의 공통된 부분을 다시 뽑아서 새로운 인터페이스인 Collection을 추가로 정의했다.

![img](https://github.com/princenim/TIL/assets/59499600/54ffb144-6149-4797-b19e-d1ae6b2a6c79)

List, Set을 구현한 컬렉션 클래스들은 서로 많은 공통점이 있어 공통된 부분을 뽑아 다시 Collection 프레임워크로 정의할 수 있었지만 Map 인터페이스는 이들과는 다르게 다른 형태로 다루기 때문에 같은 상속도계층도에 포함되지 못했다. 이러한 설계는 객체지향언어의 장점을 극명히 보여준다. 따라서 프로그래밍 실력을 어느정도 갖추게 되었을 때 컬렉션 프레임워크의 실제 소스를 분석해보면 객체지향적인 설계능력을 향상시키는데 많은 도움이 될 것이다.

- `List` : 순서가 있는 데이터의 집합. 데이터의 중복을 허용한다. - ArrayList, LinkedList, Vector
    - e.g. 대기자 명단
- `Set` : 순서를 유지하지 않는 데이터의 집합. 데이터의 중복을 허용하지 않는다.  - HashSet, TreeSet
    - e.g. 양의 정수집합, 소수의 집합
- `Map` : 키와 값의 쌍으로 이루어진 데이터의 집합. 순서는 유지되지 않으며 키는 중복을 허용하지 않으나, 값은 중복을 허용한다. - HashMap, TreeMap, HashTable, Properites
    - e.g. 우편번호, 지역번호


컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set , Map 중 하나를 구현하고 있으며 구현한 인터페이스의 이름이 클래스의 이름에 포함되어있어서 이름만으로도 클래스의 특징을 쉽게 알 수 있도록 되어있다. 그러나 Vector, Stack , Hashtable, Properties 같은 클래스들은 컬렉션 프레임워크가 만들어지기 이전부터 존재하던 것이므로 컬렉션 프레임워크 명명법을 따르지 않는다.

따라서 Vector, Hashtable 과 같은 기존 컬렉션 클래스들은 호환을 위해 설계를 변경해서 남겨주었지만 가능하면 사용하지 않는 것이 좋다. 대신 ArrayList와 Hashmap을 사용하다.

### List 인터페이스

중복을 허용하면서 저장순서가 유지되는 컬렉션을 구현하는데 사용된다. ArrayList, LinkedList , Stack

List 인터페이스에 정의된 메서드 목록

| 메서드                                                                          | 설명 |
|------------------------------------------------------------------------------| --- |
| void add(int index, Object element) ,boolean addAll(int index, Collection c) | 지정된 index에 객체(element) 또는 객체들(Collection )을 추가한다.  |
| Object get(int index)                                                        | index에 있는 객체를 반환한다.  |
| int indexOf(Object o)                                                        | 지정된 객체의 index를 반환한다. (List 첫번째 요소부터 순방향으로) |
| int lastIndexOf(Object o)                                                    | 지정된 객체의 index를 반환한다. (List 마지막 요소부터 순방향으로) |
| ListIterator listItertor(), ListIterator listItertor(int index)                                          | List의 객체에 접근할 수 있는 ListIterator 를 반환한다.  |
| Object remove(int index)                                                     | index에 있는 객체를 삭제하고 삭제된 객체를 반환한다.  |
| Object set(int index, Object element)                                        | index에 객체를 저장한다.  |
| void sort(Comparator c)                                                      | 지정된 비교자로 부터 List를 정렬한다. (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(int fromIndex, int toIndex)                                     | 지정된 범위에 있는 객체를 반환한다. from ~ to |

```java
//ListIterator 
LinkedList<String> list = new LinkedList<String>();
list.add("A");
list.add("B");
Iterator<String> iter = list.iterator();

while(iter.hasNext()) { //has.Next는 읽을 다음 여부가 있는지 반환
    System.out.println(iter.next()); //next()는 다음요소를 읽어온다.  
}
```

### Set 인터페이스

중복을 허용하지 않고 저장순서가 유지 되지 않는 컬렉션 클래스를 구현할때 사용한다. HashSet, TreeSet.

### Map 인터페이스

키와 값을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용된다. 키는 중복될수 없고, 값은 중복을 허용한다.기존에 저장된 데이터와 중복된 키에 값을 저장하면 기존의 값은 없어지고, 마지막에 저장된 값이 남겨진다. Hashtable, HashMap, LinkedHashMap, SortedMap, TreeMap

| 메서드  | 설명  |
| --- | --- |
| void clear() | Map의 모든 객체를 삭제한다.  |
| boolean containsKey(Object Key) | 지정된 key 객체와 일치하는 Map의 Key 객체가 있는지 확인한다.  |
| boolean containsKey(Object Value) | 지정된 value 객체와 일치하는 Map의 value객체가 있는지 확인한다.  |
| Set entrySet() | Map에 저장되어 있는 key-value 쌍을 Map.Entry 타입의 객체로 저장한 Set으로 반환한다.  |
| boolean equals(Object o) | 동일한 Map 인지 비교한다.  |
| Object get(Object key ) | 지정한 Key 객체에 대응하는 value객체를 찾아서 반환한다.  |
| int hashCode() | 해쉬코드를 반환한다. 각 객체의 주소값을 변환하여 생성한 객체의 고유한 정수값을 말한다.  |
| boolean isEmpty() | Map이 비어있는지 확인한다.  |
| Set keySet() | Map에 저장된 모든 Key객체를 반환한다.  |

참고로 Object는 자바가 만들어놓은 API 중에서 최상위 클래스이다. 모든 사용자가 만든 클래스는 Object로부터 상속받는다. 따라서 모든 클래스는 Object 클래스릐 메서드를 사용할 수 있다.
객체 또는 Object는 클래스에서 정의한 것을 토대로 메모리에 할당된 것을 말한다. 따라서 메모리가 할당되기 전까지 객체는 존재하지 않는다. 객체 지향 프로그래밍에서 객체는 클래스의 인스턴스다 .

keySet() 의 반환타입은 Set 이며, value() 반환타입은 Collection 이라는 것에 주목하자. Map 인터페이스에서 값은 중복을 허용하기 때문에 Collection 타입으로, key는 중복을 허용하지 않기 때문에 set 타입으로 반환한다.

### Map.Entry 인터페이스

Map.Entry 인터페이스는 Map 인터페이스의 내부 인터페이스이다. 내부 클래스와 같이 인터페이스 안에 인터페이스를 정의하는 내부 인터페이스(inner interface)를 정의하는 것도 가능하다.
Map에 저장되는 Key-value 쌍을 다루기 위해 내부적으로 Entry 인터페이스를 정의해놓았다. 보다 객체지향적으로 설계하도록 유도하기 위한 것으로 Map 인터페이스를 구현하는 클래스에서는 Map.Entry 인터페이스를 함께 구현해야한다.

## 1.2 ArrayList

ArrayList는 List 인터페이스를 구현하기 때문에 데이터의 저장순서가 유지되고, 중복을 허용한다는 특징을 갖는다. ArrayList는 Object 배열을 이용해 데이터를 순차적으로 저장한다. 배열에 더 이상 저장할 공간이 없으면 보다 큰 새로운 배열을 생성해 기존의 배열에 저장된 내용을 새로운 배열로 복사한 다음에 저장한다.

| 메서드  | 설명                                                                                                    |
| --- |-------------------------------------------------------------------------------------------------------|
| ArrayList() | 크기가 10인 ArrayList를 생성                                                                                 |
| ArrayList(Collection c) | 주어진 컬렉션이 저장된 ArrayList를 생성                                                                            |
| ArrayList(int initialCapacity) | 지정된 컬렉션이 저장된 ArrayList를 생성                                                                            |
| boolean add(Object o) | ArrayList에 마지막에 객체를 추가. 성공하면 true                                                                     |
| void add(int index, Object element) | 지정된 index에 객체를 저장                                                                                     |
| boolean addAll(Collection c) | 주어진 컬렉션의 모든 객체를 저장, 즉 붙이기                                                                             |
| void clear() | ArrayList를 완전히 비운다.                                                                                   |
| Object clone() | ArrayList를 복제한다.                                                                                      |
| boolean contains(Object o) | 지정된 객체(o)가 ArrayList에 포함되어있는지 확인                                                                      |
| void ensureCapacity(int minCapacity) | ArrayList의 용량이 최소한 minCapacity에 포함되어 있는지 확인                                                           |
| Object get(int index) | index에 저장된 객체를 반환                                                                                     |
| int indexOf(object o) | 지정된 객체가 저장된 위치를 찾아 반환                                                                                 |
| boolean isEmpty() | ArrayList가 비어있는지 확인                                                                                   |
| Iterator iterator() | ArrayList의 Iterator객체를 반환                                                                             |
| int lastIndexOf(Object o) | 객체 o가 저장된 위치를 역방향으로 검색해서 반환                                                                           |
| ListIterator listIterator() | ArrayList의 ListIterator 반환                                                                            |
| ListIterator listIterator(int index) | ArrayList의 지정된 위치부터 시작하는 ListIterator 반환                                                              |
| Object remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean remove(Object o) | 지정한 객체를 제거                                                                                            |
| boolean removeAll(Collection c) | 지정한 컬렉션에 저장된 것과 동일한 객체들을 ArrayList에서 제거                                                               |
| boolean retainAll(Collection c) | ArrayList에 저장된 객체 중에서 주어진 컬렉션과 공통된 것들만 남기고 다 삭제                                                       |
| Object set(int index, Object elemet) | 주어진 객체를 지정된 index에 저장                                                                                 |
| int size() | ArrayList에 저장된 객체의 개수 반환                                                                              |
| void sort(Comparator c) | 지정된 정렬기준으로 ArrayList 정렬  (Comparator은 Comparable 인터페이스가 없거나 기본적인 정렬 순서와는 다른 방식으로 객체를 정렬해야할 경우에 사용한다.) |
| List subList(intfromIndex, int toIndex) | fromIndex 부터 toIndex까지에 저장된 객체를 반환                                                                    |
| Object[] toArray() | ArrayList에 저장된 모든 객체들을 객체배열로 반환                                                                       |
| Object[] toArray(Object[] a) | ArrayList에 저장된 모든 객체들을 객체배열 a에 담아 반환                                                                  |
| void trimToSize() | 용량을 크기에 맞게 줄인다. 즉 빈 공간을 없앤다.                                                                          |

```java
//ArrayList 선언 
ArrayList<String> a1 = new ArrayList<String>(); //타입지정해서 선언,기본 capacity는 10
a1.add("A"); //ArrayList 마지막에 객체 추가
a1.add("B");
ArrayList<String> a2= new ArrayList<String>(50); //초기 capacity를 50으로
a2.add("C");
ArrayList<String> a3= new ArrayList<String>(a1); //주어진 Collection을 초기값으로 생성

//붙이기 addAll
System.out.println(a2.addAll(a3)); //a2 +a3 -> true
System.out.println(a2); //[C, A, B]

//복제 clone
Object a4 = a2.clone();
System.out.println(a4); //[C, A, B]

//컬렉션에 저장된 것과 동일한 객체들을
a2.removeAll(a3); // [C, A, B] - [A,B] = [C]
System.out.println(a2);
```

예제 11-2) 긴 문자열 데이터를 원하는 길이로 잘라서 ArrayList에 담은 다음 출력

```java
public static void main(String[] args) {
    final int LIMIT = 10; //자르고자 하는 글자 개수
    String source = "0123456789abcdefghijABCDEFGHIJ!@#$%^&*()ZZZ";
    int length = source.length();

    //초기 용량이 14인 리스트
    ArrayList<String> list = new ArrayList<>(length / LIMIT + 10); //여유있게 크기 잡기 48/10 + 10 = 14

    for (int i = 0; i < length; i += LIMIT) { //i = 0,10, 20, 30,40
        if (i + LIMIT < length) {
            //add는 ArrayList 마지막에 객체 추가
            list.add(source.substring(i, i + LIMIT));
        } else {
            list.add(source.substring(i));
        }
    }
    System.out.println(list);
}
```

### + Array와 ArrayList의 차이

Array와 ArrayLIst는 모든 것이 비슷하나, 가장 큰 차이점은 길이를 조정할 수 있는가 없는가이다.

자바에서 Array는 **고정길이**이다. 초기화시 배열의 크기를 지정한다. 또한 정해진 길이의 배열을 모두 채우면, 새로운 데이터를 추가하고 싶을 경우 새로운 배열을 만들어줘야한다.

하지만 ArrayList는 List컬렉션 인터페이스의 한 종류로 **가변길이**이다.  즉 동적으로 사이즈가 늘어난다. 하지만 내부적으로 Array로 구성되어 있다. ArrayList는 디폴트로 10개의 공간을 가진 배열로 시작한다. 따라서 기존 사이즈 이상으로  add()함수를 이용해 추가하려고하면 기존 배열 크기의 1.5배(기존용량 + 기존용량/2)로 resize해 새로운 배열을 만들어서 기존배열을 copy한다. 이런 원리로 ArrayList가 동적으로 크기가 늘어날 수 있는 것이다.


## 1.3 LinkedList

배열은 구조가 간단하여 사용하기 쉽고 데이터를 읽어오는데 걸리는 시간이 가장 빠르다는 장점을 가지고 있지만, 다음과 같은 **단점**을 가지고 있다.

- 크기를 변경할 수 없다. - 크기를 변경할 수 없으므로 새로운 배열을 생성해 데이터를 복사해야한다.
- 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.  - 차례대로 데이터를 추가하고 , 마지막부터 삭제하는 것은 빠르지만, 배열의 중간에 데이터를 추가하려면 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야한다.

이러한 배열의 단점을 보완하기 위해서 LinkedList라는 자료구조 형태가 나왔다. **링크드리스트는 메모리상에서 불연속적으로 존재하는 데이터를 서로 연결한 형태**로 구성되어있다.

<img width="614" alt="a" src="https://github.com/princenim/TIL/assets/59499600/01f8dd9f-777e-443a-bb8a-72a3866031db">

![b](https://github.com/princenim/TIL/assets/59499600/0cf1c93a-8e28-4173-9790-82bada38d540)

링크드리스트의 각 요소(Node)들은 자신과 연결된 다음 요소에 대한 **참조(주소값)과 데이터**로 구성되어 있다.

```java
class Node{
  Node next; //다음 요소의 주소를 저장
  Object obj; // 데이터를 저장
}
```

링크드 리스트의 삭제는 간단한데. 삭제하고자하는 요소의 이전요소가 삭제하고자하는 요소의 다음 요소를 참조하다록만 변경하면 된다. 새로운 데이터를 추가할 때는 새로운 요소를 생성한 다음 추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소로 참조로 변경하고, 새로운 요소가 그 다음 요소를 참조하도록 변경하기만 하면 된다.

참고로 Linkedlist는 ArrayList와 달리 인덱스가 존재하지 않는다. 따라서 순차탐색이 필요하다.

### 더블 링크드 리스트

![c](https://github.com/princenim/TIL/assets/59499600/eb6470ed-9604-4843-98e1-7f6b3d0d3f32)

하지만, 이런 링크드 리스트 이동방향이 단방향이기때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접은은 어렵다. 예를들어 링크드 리스트에 저장된 데이터가 10000개라면 9999번째 데이터에 접근하려면 9999번 이동해야한다. 이러한 단점을 해결한것이 **더블 링크드 리스트 (이중 연결리스트, doubly linked list) 이다.** 링크스 리스트에 참조변수를 하나 더 추가해 다음 요소에 대한 참조뿐만이 아니라 이전 요소에 대한 참조가 가능하도록 했다.

```java
class Node{
  Node next; //다음 요소의 주소를 저장
  Node previous; //이전 요소의 주소를 저장
  Object obj; // 데이터를 저장
}
```

### 더블 써큘러 링크드 리스트

<img width="720" alt="d" src="https://github.com/princenim/TIL/assets/59499600/e28ea4fd-2077-4323-9692-ef2cc231448a">

더블 링크르 리스트의 접근성을 보다 향상시킨 것이 더블 서큘러 링크드 리스트(이중 원형 연결리스트, doubly circular linked list)이다. 단순히 더블 링크드 리스트의 첫번째와 마지막 요소를 서로 연결시킨 것이다. 따라서 마지막 요소의 다음 요소가 첫번째 요소가 되고, 첫번째 요소의 이전 요소가 마지막 요소가 된다. 따라서 링크드리스트에 저장된 데이터가 10000개 일때 9999번째 데이터에 접근하기 위해 9999번째를 이동하지 않아도 된다.

실제로 자바의 LinkedList의 클래스는 링크드리스트라는 이름이 아닌 더블링크드리스트로 구현되어 있다.

| 메서드  | 설명  |
| --- | --- |
| LinkedList() | LinkedList 객체 생성 |
| LinkedList(Collection c) | 주어진 컬렉션을 포함하는 LinkedList 객체를 생성 |
| boolean add(Object o) | 지정된 객체(o)를 LinkedList의 끝에 추가. 저장에 성공하면 true, 실패하면 false |
| void add(int index, Object element) | 지정된 index에 객체를 추가  |
| boolean addAll(Collection c) | 주어진 컬렉션에 포함된 모든 요소를 LinkedList의 끝에 추가한다.  |
| boolean addAll(int index, Collection c) | 지정된 위치에 주어진 컬렉션에 포함된 모든 요소를 추가한다.  |
| void clear() | LinkedList안에 모든 요소를 삭제한다.  |
| boolean contains(Object o) | 지정된 객체가 lInkedList에 포함되었는지 알려준다.  |
| boolean containsAll(Collection c) | 지정된 컬렉션의 모든 요소가 포함되었는지 확인한다.  |
| Object get(int index) | index로 객체를 반환한다. index를 통한 get 매소드를 제공하지만 실제로는 순차탐색으로 이루어져있다.  |
| int indexOf(Object o) | 지정된 객체가 저장된 위치를 반환한다.  |
| boolean isEmpty() | LinkedList가 비어있는지 알려준다.  |
| Iterator Iterartor() | Iterator를 반환한다.  |
| int lastIndexOf(Object o) | 지정된 객체가 저장된 위치를 끝부터 검색해 반환한다. |
| ListIterator listIterator() | ListIterator를 반환한다.  |
| ListIterator listIterator(int index) | 지정된 위치에서부터 시작하는 ListIterator를 반환한다.  |
| Object remove(int index) | 지정된 위치의 객체를 LinkedList에서 제거한다.  |
| boolean remove(Object o) | 지정된 객체를 linkedList에서 제거한다.  |
| boolean removeAll(Collection c) | 지정된 컬렉션의 요소와 일치하는 요소를 모두 삭제  |
| boolean retainAll(Collection c) | 지정된 컬렉션의 모든 요소가 포함되어있는지 확인 |
| Object set(int index, Object element)  | 지정된 위치의 객체를 주어진 객체로 바꾼다.  |
| int size() | LinkedList의 저장된 객체 수를 반환 |
| List subList(int fromIndex, int toIndex) | LinkedList의 일부를 List로 반환 |
| Object[] toArray() | LinkedList에 저장된 객체를 배열로 반환 |
| Object[] toArray(Object[] a) | LinkedList에 저장된 객체를 주어진 배열에 저장해 반환 |
| Object element() | LinkedList의 첫번째 요소를 반환 |
| boolean offer(Object o) | 지정된 객체(o)를 lInkedList의 끝에 추가.  |
| Object peek() | LinkedList의 첫 번째 요소를 반환 |
| Object poll() | LinkedList의 첫번째 요소를 반환 후 LinkedList에서 제거 |
| Object remove() | LinkedList의 첫번째 요소를 제거  |
| void addFirst(Object o) | LinkedList의 맨 앞에 객체 o 추가  |
| void addLast(Object o) | LinkedList의 맨 끝에 객체 o 추가 |
| Iterator descendingIterator() | 역순으로 조회하기 위한 DescendingIterator를 반환 |
| Object getFirst() | LinkedList의 첫번째 요소를 반환 |
| Object getLast() | LinkedList의 마지막 요소를 반환 |
| boolean offerFirst(Object o) | LinkedList의 맨 앞에 객체 o를 추가  |
| boolean offerLast(Object o) | LinkedList의 맨 끝에 객체 o를 추가  |
| Object peekFirst() | LinkedList의 첫번째 요소를 반환 |
| Object peekLast() | LinkedList의 마지막 요소를 반환 |
| Object pollFirst() | LinkedList의 첫번째 요소를 반환하면서 동시에 제거 |
| Object pollLast() | LinkedList의 마지막 요소를 반환하면서 동시에 제거 |
| Object pop() | removeFirst() 와 동일. 첫번째 요소를 제거  |
| void push(Object o) | addFirst()와 동일. 맨 앞에 객체 o를 추가  |
| Object removeFirst() | LinkedList의 첫번째 요소를 제거  |
| Object removeLast() | LinkedList의 마지막 요소를 제거  |
| boolean removeFirstOccurrence(Object o) | 첫번째로 일치하는 객체를 제거  |
| boolean removeLastOccurrence(Object o) | 마지막으로 일치하는 객체를 제거 |

```java
//링크드 리스트 객체 생성
LinkedList<String> l1 =  new LinkedList<>();
l1.add("A"); // ["A"]

//주어진 컬렉션을 포함하는 LinkedList 객체 생성
LinkedList<String> l2 = new LinkedList<>(l1); //["A"]
```

(참고로 LinkedList는 Queue 인터페이스와 Deque 인터페이스를 구현하도록 변경되었는데, 마지막 22개의 메소드는 Queue 인터페이스와 Deque 인터페이스를 구현하면서 추가된 것이다. )

ArrayList와 Array를 비교한다면

1. **순차적으로 추가/삭제하는 경우에는 ArrayList가 LinkedList보다 빠르다.** ArrayList를 처음 생성할때 저장할 데이터의 개수만큼 충분한 초기용량을 확보한상태라면 저장공간이 부족해서 새로운 ArrayList를 만들고 복사하는 일을 발생하지 않기 때문에 순차적으로 데이터를 추가한다면 LinkedList보다 Arraylist가 더 빠르다. 또한 데이터를 순차적으로 삭제한다는 것은 마지막 데이터부터 역순으로 삭제해나간다는 것을 의미하므로 ArrayList는 마지막 데이터부터 삭제할경우 요소들의 재배치가 필요하지 않기 때문에 상당히 빠른다. 단지 마지막 요소의 값을 null로만 바꾸면 되니까.

2. **중간 데이터를  추가/삭제하는 경우에는 LinkedList가 ArrayList보다 빠르다.** 중간 요소를 추가,삭제하는 경우 LInkedList는 각 요소간의 연결만 변경해주면 되므로 처리속도가 빠르다. 하지만 ArrayList는 요소를 재배치해 공간을 확보 또는 빈 공간을 채워야하기때문에 처리속도가 늦다.

```java
public class ArrayListLinkedListTest {
    public static void main(String[] args) {
        //생성
        ArrayList<Object> a1 = new ArrayList<>(1000000);
        LinkedList<Object> l1 = new LinkedList<>();

        //데이터 추가
        add(a1);
        add(l1);

        System.out.println("= 접근시간테스트 ==");
        System.out.println("ArrayList: " + access(a1)); //1
        System.out.println("LinkedList: " + access(l1));//317
    }

    public static void add(List list) {
        for (int i = 0; i < 1000000; i++) {
            list.add(i + "");
        }
    }

    public static long access(List list) {
        long start = System.currentTimeMillis(); //현재시각을 밀리세컨드 단위로 반환
        for (int i = 0; i < 10000; i++) {
            list.get(i);
        }
        long end = System.currentTimeMillis();
        return end - start; //걸리는 시간
    }
}
```

ArrayList와 LinkedList의 접근시간테스트를 해보면 Arraylist가 LinkedList보다 현저히 빠르다. 그 이유는 배열의 경우 만일 인덱스가 n인 요소의 값을 얻어 오고자 한다면 단순히 아래와 같은 수식을 계산함으로써 해결한다

***인덱스가 n인 데이터의 주소 = 배열의 주소 + (n * 데이터 타입의 크기)***

```java
Object[] arr = new Object[5];
//arr[2]의 주소? 
```

Object배열 arr 이 선언되었을 때 **arr[2]**에 저장된 값을 읽으려 한다면 **n은 2** , **모든 참조형 변수의 크기는 4byte** , 생성된 배열의 주소는 ox100이므로 3번째 데이터가 저장되어 있는 주소는 ***ox100 + 2 * 4 = ox108*** 이 된다.

따라서 배열은 메모리상에서 요소들이 연속적으로 존재하기때문에 간단한 계산으로 원하는 요소의 주소를 얻을 수 있지만, LinkedList는 요소들이 불연속적으로 위치하기때문에 처음부터 n 번째 데이터까지 차례대로 따라가야만 원하는 값을 얻을 수 있다. 그래서 LinkedLists는 데이터의 개수가 길어질수록 데이터를 읽어 오는 시간. 즉 access time이 길어진다는 단점이 있다.

| 컬렉션 | 읽기(접근시간) | 추가/삭제 | 비고 |
| --- | --- | --- | --- |
| ArrayList | 빠르다  | 느리다 | 순차적인 추가,삭제는 더 빠름.  |
| LinkedList | 느리다 | 빠르다 | 데이터가 많을수록 접근성이 떨어짐. |

즉! 데이터의 개수가 변하지 않는 경우라면 ArrayList가 최상의 선택이 되겠고, 데이터 개수의 변경이 잦다면 LinkedList를 사용하는 것이 더 나은 선택이다.