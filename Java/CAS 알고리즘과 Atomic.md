# **📌**  CAS 알고리즘과 Atomic

# 1. Atomic

멀티쓰레드 환경에서 `synchronized` 키워드를 사용해서 동기화를 구현할 수 있다. `synchronized`를 사용하면 해당 블럭 전체를 lock(점유)하기 때문에 다른 Thread는 아무런 작업을 하지 못하고 기다리게된다. 다시말해 이때 블럭에 접근하는 쓰레드들은 `block` 상태가 된다. 즉 쓰레드들이 `blocking` 되는 과정과 다시 `resuming` 되는 과정에서 시스템의 자원을 사용하게되는데. 바로 이 부분에서 성능 저하가 발생한다.

이러한 문제를 해결하기 위해 `non-blocking` 방식을 사용하여 `원자성`을 보장하기 위한 방법이 `Atomic`이다.

`원자성`이란 어떤 작업이 프로그램 안에서 가장 작은 단위라서 더 이상 다른 작업으로 나누어 지지 않는 것을 말한다.

`Atomic`의 핵심원리가 바로 `CAS(Compare And Swap)알고리즘`이다.

자바에서는 `java.util.concurrent.atomic` 패키지에서 원자적인 연산을 지원하는 클래스를 제공하고 이 클래스들은 모두 `CAS(Compare And Swap)알고리즘` 로 구현되어있다.

# 2. CAS 알고리즘

멀티 코어 환경이나 멀티 쓰레드 환경에서 각 CPU는 메인 메모리에서 변수값을 참조하지 않고 각 CPU의 캐시 영역에서 값을 참조한다. 이때 메인 메모리와 캐시에 저장된 값이 다른 경우가 있다.  이를 `가시성` 이라고 한다. 이 가시성 문제를 해결하는 알고리즘이 CAS 알고리즘이다 .

**현재 쓰레드에 저장된 값(캐시)과 메인메모리에 저장된 값을 비교해 일치하는 경우 새로운 값으로 교체 , 일치하지 않으면 다시 재시도를 한다.** 이렇게 처리하면 CPU 캐시에서 잘못된 값을 참조할수 없어 가시성 문제가 해결된다.

다시말해 값이 다르다는것은 쓰레드A가 공유변수에 대해서 계산을 하고 메모리에 반영하기 전에 쓰레드 B가 공유변수를 변경해 메모리에 반영한 경우를 말한다. 즉 쓰레드 A의 계산을 메모리에 반영하면 안된다. 그래서 실패를 하고 다시 시도를 하는 것이다.

![ㅊㅁㄴ](https://github.com/princenim/TIL/assets/59499600/75ef1587-b711-4711-a658-0b199c0925cd)

CAS 알고리즘의 동작 원리는 다음과 같다.

1. 인자로 기존 값(Compared value)와 변경할 값(Exchanged value)를 전달한다.
2. 기존값(Compared value)이 현재 메모리가 가지고 있는 값과 같다면 변경할 값(Exchanged value)을 반영해 true를 반환한다.
3. 반대로 기존 값(Compared value)이 현재메모리가 가지고 있는 값(destination)과 다르다면 값을 반영하지 않고 false를 반환한다.

![cas](https://github.com/princenim/TIL/assets/59499600/4a119b34-86d8-4b9d-a2d0-7f98696a510e)

위의 이미지를 예시로 더 자세하게 설명하면

1. `Thread1`과 `Thread2`는 메인 메모리에있는 `counter` 변수를 읽어 CPU 캐시에 저장한다.
2. 각 쓰레드는 `counter` 값을 연산한다.
3. `Thread1`과 `Thread2`는 연산하고 난 counter값을 메인 메모리에 반영하기 전의 counter값과 메인메모리에 저아된 counter값을 비교한다.
    1. 기존 값이 메인 메모리가 가지고 있는 값과 다르다면 값을 반영하지 않고 false를 리턴해 메인 메모리에 저장된 값을 읽어 2번으로 돌아간다.
    2. 기존 값이 메인 메모리가 가지고있는 값과 같으면 변경할 값을 반영하고 true를 리턴한다.


**참고로 자바의 멀티쓰레드 환경에서 메인 메모리는 모든 쓰레드가 공유하는 메모리 영역을 말하며 캐시는 쓰레드 캐시를 말한다.**

![jvm multi](https://github.com/princenim/TIL/assets/59499600/1d0cc29b-a213-44b6-96fc-021093ff92b9)