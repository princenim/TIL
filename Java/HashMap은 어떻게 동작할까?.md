# **📌 HashMap은 어떻게 동작할까?**

# 1. HashMap

![collection](https://github.com/princenim/TIL/assets/59499600/a13ce08e-37e5-4130-9bc1-be7f7fcf1b87)

```java
public class HashMap<K,V> extends AbstractMap<K,V>
    implements Map<K,V>, Cloneable, Serializable {
```

- `HashMap`은 자바 컬렉션 프레임워크의 일부로 `Map`을 구현한 맵 기반의 클래스이다.
- `HashMap`은 `Key-value` 형태로 데이터를 저장한다. 이때 `key`는 중복이 불가능하며 `value`는 중복이 가능하다.
    - `value`는 키와 값을 저장하는 `Entry`라는 클래스로 정의되어있다.
- `HashMap`은 내부적으로 해시 함수를 사용해서 키를 해시코드로 매핑하고, 해당 해시코드를 기반으로 인덱스를 계산해 값을 저장한다. 여기서 해시함수는 `hashCode()`를 말한다.
- `HashMap`은 순서를 보장하지 않는다. 키의 순서는 해시코드에 기반하기 때문에 순서가 중요한 경우에는 `LinkedHashMap`을 사용해야한다.
- 내부적으로 `배열`과 `LinkedList`로 이루어져있다.
  - `HashMap`은 내부적으로 `배열(버킷)`을 사용해 데이터를 저장한다. 각각의 `key`값 에 해시 함수를 적용해 고유한 인덱스를 생성 후 값을 저장한다. 이때 실제 값이 저장하는 곳을 `버킷(bucket)`이나 `슬롯`이라고 한다. 만약에 같은 `버킷` 인덱스에 할당되면 `key`를 확인하고 다른 값이면 `LinkedList`로 다음 노드에 해당 값을 저장한다.

## 1.1 Hashmap의 구현

`해싱`이란 `해시함수(Hash Function`)을 사용해 데이터를 해시테이블에 저장하고 검색하는 기법을 말한다. 이 해싱을 구현한 클래스로는 `HashSet`, `HashMap`, `HashTable`이 있다.

<img width="881" alt="스크린샷 2024-01-23 오후 9 08 38" src="https://github.com/princenim/TIL/assets/59499600/4a1e1151-06e6-434a-97c1-129291f28dea">

![hashmap](https://github.com/princenim/TIL/assets/59499600/39618b42-4114-4f4c-9a25-84c8d63c0336)

위의 그림은 `HashMap`의 저장된 데이터를 찾는 구조이다.  내부의 순서는 다음과 같다.

1. 해시함수에 키를 넣어서 해시코드를 얻으면 그 해시코드를 가지고 배열의 인덱스로 사용한다. Java에서는 `Object`의 `hashCode()` 메소드를 이용해서 `int` 형태의 해시코드를 얻는다.
2. 해시코드에 절대값을 취하고 그 다음에 배열의 크기(버킷의 개수)를 나눈 나머지를 계산한다. 이렇게 하면 해시 코드가 음수인 경우에도 양수로 변환되고, 배열의 크기에 맞는 인덱스를 구할 수 있다. 그리고 나머지 연산을 통해 나온 값이 인덱스이다.

```java
int index = X.hashCode() % M;
```

3.인덱스를 가지고 인덱스에 해당하는 배열에 `Entry`구조의 `key-value` 값을 저장한다.



![bucket2](https://github.com/princenim/TIL/assets/59499600/66522baa-fc3a-4f26-824b-202805f26bbf)

```java
static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next
...
}
```

```java
Bucket 0: [Entry1, Entry2, ...]
Bucket 1: [Entry3, ...]
Bucket 2: []
Bucket 3: [Entry4, ...]
```

`HashMap` 은 `배열` 과 `linkedList`로 이루어져있다.

하지만  `자바 8`부터는 같은 해시 인덱스에 일정크기 이상의 노드가 존재하면 `Linkedlist`가 아닌 `레드블랙 트리`의 자료구조를 가지고 데이터를 저장한다. 그렇다면 왜 `레드블랙트리`를 사용할까?

### 레드 블랙 트리

이유는 `LinkedList`를 사용해서 검색을 하게 되면 시간복잡도가 `O(N)`으로 모든 `LinkedList`에 연결된 객체를 다 확인해야 하기 때문이다.

`트리`란 나무가지처럼 노드들이 연결된 비 선형 자료구조를 말한다. 만약 이진 탐색 트리를 사용한다면 오른쪽 노드는 부모노드보드 큰 숫자들이, 왼쪽 노드들은 부모노드보다 작은 숫자들이 저장된다. 하지만 이 이진탐색트리는 한쪽으로 편향될 가능성이 있다. 이렇게 된다면 똑같이 시간복잡도가 `O(N)`이 된다. `LinkeList`를 쓰는 것과 다름이 없다. 따라서 이런 편향을 방지할 수 있는 `레드블랙트리`를 사용한다.

`레드블랙트리`는 밸런스 잡힌 트리로 데이터가 추가되면 위치를 바꿔서 삼각형을 다시 만든다. 즉 스스로 균형을 맞춘다. 따라서 insert와 delete의 성능을 약간 포기하고, **읽기 성능에 집중한 자료구조이다.**

즉, `HashMap`에서는 노드가 8개 이상이 되면 `레드 블랙 트리`를지고 읽기 성능을 더 올린다.

```java
//8개 이상의 키-값 쌍이 모이면 트리로 변경
static final int TREEIFY_THRESHOLD = 8;
```

## 1.2  해싱충돌(Hash Collision)

위의 hashCode() 메소드의 리턴값은 int다. 즉 해시코드의 범위가 정해져있다는 말이다. 객체는 무한대로 생성이 가능한데 객체의 고유한 정수값을 리턴하는 해시값은 무한하지 않다. 즉 다시말해서 **다른 Key값이라도 같은 해시값이 나올 수 있다. 이를 해시 충돌(Hash Collision)이라고 한다.**

이러한 해시 충돌을 완화하는 방법에는 **분리 연결법, 개방 주소법** 2가지가 존재한다.

### 분리 연결법(separate chaining)

![chaining2](https://github.com/princenim/TIL/assets/59499600/bd0a2a68-c412-4942-8e0f-e16d8581be64)

충돌이 발생하면 동일한 버킷의 데이터를 `LinkedList` 또는 `트리` 자료구조를 사용해 연결하는 방법을 말한다. 즉 추가 메모리를 사용해 다음 데이터의 주소를 저장한다.

이 방법에 `LinkedList`를 사용할 시 순차적으로 모든 노드를 확인해야한다. 따라서 `LinkedList`의 크기가 커질수록 검색속도가 덜어지게 된다. 따라서 최악의 경우 시간복잡도가 `O(n)`이다. 또한 메모리가 연속적으로 배치되지 않아서 캐시 효율성이 감소될 수 있다. 간단히 설명하면 캐시는 주로 근접한 주소에 위치한 데이터에 더 높은 성능을 보이는 특징이 있다.

하지만 Java8 부터는 데이터의 개수가 일정 이상일 때는 `LinkedList` 가 아닌 `Tree`를 사용한다.

### 개방 주소법(open -address)

![chaining](https://github.com/princenim/TIL/assets/59499600/95476aea-2d2c-4cdf-bd89-53c06aac6978)

또 다른 방법은 개방 주소법이다. 해싱 충돌이 발생하면 비어있는 다른 위치를 탐색하는 방법이다. 이 개방주소법을 구현하는 3가지 방법이 존재한다.

1. **선형탐사 (Linear Probing)**: 해싱 충돌이 발생하면 다음 위치로 선형적으로 이동하며 빈 버킷을 찾는다. 예를 들어 해시 함수를 H로 정의 했다면 충돌이 발생했을 때 `H(Key) +1, H(Key) +2...`  순서로 탐색한다. 이 방법은 구현이 간단하지만 특정 해시 값의 주변이 모두 채워져있는 일차 군집화 (primary clustering)문제가 발생할 수 있다. 따라서 해시 성능이 크게 저하될 가능성이 있다.
2. **이차 탐사 (Quadratic Probing)** : 해싱 충돌이 발생하면 제곱 함수를 사용해 다음 위치를 찾는다.  예를 들어 해시 함수를 H로 정의 했다면 충돌이 발생했을 때 `H(Key) +1^2, H(Key) +2^2 ...` 순서로 탐색한다. 이 방법은 선형탐사법보다 군집화가 일어날 가능성이 적지만 제곱함수를 사용하므로 일부 위치에 몰리는 경향이 있다. 이로 인해 영역 중 일부는 활용되지 않고 메모리 사용이 비효율적이 될 수도있다.
3. **이중 해싱(Double Hashing Probing)** : 두 번째 해싱 함수를 사용해 다음 위치를 찾는다. 첫 번째 해시 함수를 H1(key), 두 번째 해시 함수를 H2(key)로 정의했을 때, 충돌이 발생하면 `H1(key) + i * H2(key) (i는 0, 1, 2, ...)` 순서로 탐색한다. 이 방법은 두 번째 해싱 함수를 첫번째 해싱함수와 비슷하게 구현했을시 충돌이 다시 발생할 가능성이 높아진다. 따라서 일정한 패턴의 클러스터링이 발생할 수 있다.

위의 개방 주소법 모두 해당 위치가 비어있을 때까지 계속해서 탐사를 진행한다. 하지만 모든 위치가 차 있을 경우 충돌을 해결하지 못하고 해시 테이블을 확장하는 단점이 있으며, 기존 해시테이블 내부에서 충돌을 해결하므로 메모리 사용이 효율적이라는 장점을 가지고 있다.

## 1.3 로드 팩터(Load factor)

```java
    /**
     * The default initial capacity - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

    /**
     * The load factor used when none specified in constructor.
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

`HashMap`의 `capacity(용량)`은 `16`이다. 즉 처음 내부적으로 생성되는 배열(버킷)의 크기가 16이라는 의미이다. 또한  `load factor(로드팩터)`는 `0.75`이다. 즉 용량의 0.75가 찼을때 내부적으로 배열의 크기를 `2배` 늘린다.

**그렇다면 왜 ArrayList의 로드팩터는 1인데 HashMap의 기본 로드팩터는 0.75일까?**

이유는 해싱 충돌때문이다.  해시함수를 통해 해시값을 구하고 인덱스를 구하면 동일한 인덱스를 가질 가능성이 있고, 해싱 충돌이 일어나면 추가적인 탐색 기간이 소요되기 때문에 이러한 해시충돌을 줄이기위해 0.75만큼 용량이 찼을 때, 미리 배열을 늘려 해시 충돌의 가능성을 줄이는 것이다.

## 1.4 주요 메소드의 시간복잡도

- `put(key, value)`:  지정된 키와 값을 저장
    - 시간복잡도 :   평균적으로`O(1)` 하지만 해시 충돌이 발생하는 경우 최악의 경우에는 O(n)까지 소요될 수 있다.
- `remove(key)`: 지정된 키로 값을 삭제
    - 시간복잡도 :  평균적으로`O(1)` 이나 최악의 경우 모든 키가 같은 버킷에 매핑되고 해당 버킷내의 모든 요소를 확인해야할때 `O(n)`까지 소요될 수 있다.
- `get(key)`:  키로 값을 가져옴
    - 시간복잡도 :  평균적으로  `O(1)` 이나, 최악의 경우에는 `O(n)`까지 소요된다.
- `containsKey(key)`:
    - 시간복잡도 :  평균적으로`O(1)` 이나 최악의 경우 모든 키가 같은 버킷에 매핑되고 해당 버킷내의 모든 요소를 확인해야할때 `O(n)`까지 소요될 수 있다.
- `keySet()`, `values()`:
    - 시간복잡도 : `O(n)` 으로 모든 키 또는 값에 접근하기 위해 전체 맵을 탐색해야 한다.  