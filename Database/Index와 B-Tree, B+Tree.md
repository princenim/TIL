# 📌 Index와 B-Tree, B+Tree

# 1. 인덱스란?

mysql 인덱스는 조회 성능을 높이기 위해 사용하는 방법입니다. 추가 공간을 사용해 정렬된 데이터를 저장하여 인덱스가 걸린 칼럼은 빠르게 데이터를 조회할 수 있습니다. 하지만 항상 정렬된 상태를 유지해야하므로 데이터가 추가/삭제 될때마다 정렬해야 하기때문에 삽입, 삭제 시 성능이 떨어지게 됩니다.

## 1.1 인덱스의 종류

인덱스는 데이터 저장 방식에 따라 `클러스터형 인덱스`와 `논클러스터형 인덱스`로 나뉩니다.

### 클러스터형 인덱스 (Clustered index)

이름 그대로 데이터를 한곳으로 모았다는 뜻으로 항상 정렬된 상태를 유지한다.  각 테이블마다 하나의 클러스터형 인덱스를 가질 수 있다 왜냐하면 데이터 자체가 인덱스 순서대로 정렬되기 떄문이다. 일반적으로 기본 키(Primary Key)가 클러스터형 인덱스로 설정된다.

### 논클러스터형 인덱스 (Non-Clustered index)

논클러스터형 인덱스는 테이블의 데이터와는 별도로 저장되는 인덱스이다. 이 인덱스를 테이블의 데이터 행을 참조하는 포인터를 갖고 있다. 하나의 테이블의 여러 개의 논클러스터형 인덱스를 생성할 수 있다.


# 2. 인덱스의 자료구조

인덱스는 B-Tree 인덱스, Hash 인덱스, Fractal Tree 인덱스 등이 있는데  mysql index는 B-Tree(Balanced Tree)구조를 따른다.

## 2.1 B-Tree (Balanced Tree)

먼저 `B-Tree 자료구조`는 자식 2개만을 갖는 `이진 트리(Binary Tree)`를 확장해 N개의 자식을 가질 수 있도록 고안된 자료구조이다. 또한 스스로 균형을 맞춘다는 의미로 `균형 트리`라고도 한다. 따라 조회 시 O(logN)의 시간복잡도를 가지며 이는 대량의 데이터에서 빠른 검색을 가능하게 해준다.

B-Tree 는 최상위에 하나의 `루트 노드(루트 페이지)`가 존재하고, 그 하위에 자식 노드가 붙어있는 형태이다. 트리 구조의 가장 하위를 `리프 노드(리프 페이지)`라고 하고 , 트리구조에서 루트 노드와 리프노드를 제외한 모든 노드를 `인터널 노드`라고한다. 그리고 부모 노드를 기준으로 왼쪽 자식 노드는 더 작으며, 오른쪽 자식 노드는 더 크다.

mysql은 노드를 페이지라고 부른다. 인덱스는 페이지 단위로 저장되며, 항상 인덱스 키를 바탕으로 정렬된 상태를 유지한다. 페이지 사이즈는 16KB이다.  인덱스 탐색은 Root → Branch →  Leaf → 디스크 저장소 순으로 진행된다.  따라서 select를 하면 특정 키 값을 찾기 위해 자식 페이지를 계속 타고 들어가 마지막 리프 노드에는 데이터의 레코드 주소를 찾아 하고 이 값으로 테이블 레코드를 찾을 수 있다.

![b](https://github.com/user-attachments/assets/2ededa04-225e-47d3-b239-598b2d559cc0)

하지만 인덱스를 설정하면 데이터 변경 작업 (Insert, Update, Delete)시 마다 균형을 맞춰야 하기 때문에 즉 페이지 분할 작업이 일어나기 때문에 성능이 나빠진다.

`페이지 분할`이란, 하나의 페이지가 가득 차서 더 이상 삽입할 수 없을 때, 새로운 페이지를 생성하고 데이터를 나누어 저장하는는 작업을 말한다. 따라서 insert,update, delete 등의 데이터 작업이 빈번한 테이블에는 성능에 영향을 끼치므로 인덱스 사용을 잘 고려해야한다.

새 데이터를 삽입할 때 현재 페이지가 가득 차면 페이지 분할이 발생하고, 기존 페이지의 데이터를 두 페이지로 나누어 저장한다. 이 과정에서 인덱스의 구조가 재조정되고 상위 브랜치 페이지에도 변경이 발생할 수 있다.

## 2.2  B+Tree (Balanced Tree)

![b+tree](https://github.com/user-attachments/assets/0232a02c-7986-42d2-b681-1c4f1fc15f23)

B+Tree는 B-Tree에서 확장된 개념이다. 가장 큰 차이점은 다음과 같다.

|  | B-Tree | B+Tree |
| --- | --- | --- |
| 데이터 저장 | 모든 노드에 키와 값 저장 가능 | 오직 리프 노드에만 키와 값이 저장되고, 리프 노드를 제외한 모든 노드에는 키만 저장된다.  |
| 트리의 높이 | 높다 | 낮다( 한 노드 당 키를 많이 저장할 수 있다)  |
| 링크드 리스트 | 없다. 따라서 순차 탐색의 경우 모든 노드를 개별적으로 탐색해야 한다.  | 리프 노드끼리 링크드 리스트로 연결
따라서 재 검사 시 리프노드에서 선형 검색으로 시간 복잡도가 줄어든다.  |

링크드 리스트를 좀 더 설명하자면

```css
          [30]
         /    \
     [10, 20]  [40, 50]
```

다음과 같은 B-Tree가 있을때 10 ~ 50 범위 내의 값을 찾는다면 [30] → [10,20] → [40,50] 순으로 탐색한다.

```css
         [30]
         /    \
      [20]    [40]
     /   \    /   \
  [10, 20] [30] [40, 50]
(리프 노드끼리 링크드 리스트로 연결)
```

다음과 같은 B+Tree가 있을때 10~50 범위 내의 값을 찾는다면 리프 노드가 링크드 리스트로 연결되어있으므로[30] → [20] → [10,20] → [30] → [40,50] 순으로 탐색한다. 따라서 범위내의 값을 더 효율적으로 찾을 수 있다.

# 3. 인덱싱 설정 시 고려사항

- 데이터 변경이 적은 칼럼에 추가하는 것이 좋다.
- 중복도가 낮는 칼럼에 추가하는 것이 좋다.
- 단일 테이블에 인덱스가 많으면 속도가 느려질 수 있다.  테이블 당 4~5개 권장
- 데이터가 많은 테이블에 사용해야한다.