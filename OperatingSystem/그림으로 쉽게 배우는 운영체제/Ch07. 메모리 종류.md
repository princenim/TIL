# 6. 컴파일과 프로세스
## 6.1 컴파일과 프로세스

1. 컴파일언어 : 개발자가 작성한 코드를 컴파일을 거쳐서 0과 1로된 기계어로 실행파일을 만든다. 그리고 개발자가 문법오류를 일으켰는지 컴파일 시점에 확인한다. 대표적으로 C,C++ 이 있다.
2. 인터프리터 언어 : 개발자가 작성한 코드를 미리 기계어로 만들지 않고,실행 코드를 한 줄씩 해석해 실행하는 언어이다. 대표적으로 Javascript가 있다.

### 컴파일 과정

C언어의 컴파일 과정이다.

![1](https://github.com/user-attachments/assets/abd0d4e9-e198-4c39-8475-b2fc696e9b75)

1. 전처리기는 파일을 훑어보고 전처리 구문을 처리한다.
2. 컴파일러는 작성된 파일을 기계어에 가까운 어셈블리어로 변환시킨다.
3. 어셈블러는 파일을 0과 1로된 기계어로 구성된 오브젝트 파일로 바꾼다. 이 오브젝트 파일에는 코드영역과 데이터영역이 나뉘어져있다.
4. 링커 여러개의 오브젝트 파일들을 하나의 코드영역과 데이터영역으로 묶는다. 그리고 실제로 실행될 주소를 매핑시켜준다.
5. 이렇게 .exe 프로그램이 만들어지고 이 .exe 프로그램은 완벽한 형태의 코드영역과 데이터영역으로 이루어져있다.

**이제 .exe 프로그램을 사용자가 실행하면 운영체제가 프로세스를 만든다. 그리고 운영체제는 .exe 파일안에 있는 코드영역과 데이터영역을 가져와 프로세스의 코드영역과 데이터영역에 넣어주고 빈 상태의 스택과 힙을 할당한다. 그리고 PCB를 만들어 관리가 가능하도록 만들고 프로그램 카운터 즉, 다음 실행할 명령어의 주소를 생성한 프로세스의 코드영역의 첫번째 주소로 설정한다.**

이제 운영체제의 CPU 스케줄링에 따라서 프로세스가 실행되다가 작업을 마친다.

## 6.2 정리

컴퓨터가 실행되면 모든 프로그램은 운영체제의 의해서 관리된다. 프로그램도 하드디스크에 저장이 되어있다가 사용자가 프로그램을 실행하면 메모리에 올라간다. 이 메모리에 올라간 프로그램을 프로세스라고 부른다. 이 프로세스는 CPU를 기다리고 운영체제가 공평하게 프로세스에게 CPU를 할당해준다. 이를 CPU 스케줄링이라고 한다.

 # 7. 메모리 종류
## 7.1 메모리의 종류

![2](https://github.com/user-attachments/assets/e90f31cd-2091-4ae9-8188-bdb01e12ab25)

1. **레지스터** : 가장 빠른 기억장소로 CPU 내에 존재한다. 컴퓨터가 꺼지면 데이터가 사라지기 때문에 휘발성 메모리하고 한다. CPU를 말할 때 32bit와 64bit는 레지스터의 크기를 말한다. 예를들어 32bi 레지스터를 가지고 있으면 32bit CPU라고 말한다. CPU는 계산을 할때 메인메모리에 있는 값을 레지스터에 가져와 계산을 한다. 그리고 메인메모리에 결과를 다시 저장한다.
2. **캐시** : 휘발성 메모리로 엄청 빠른 레지스터에 비해 메인메모리은 느리다. 따라서 메인메모리에서 필요한 데이터를 미리 가져와 저장하는 곳이 캐시이다. 만약 CPU가 값을 요청해 레지스터로 값을 옮겨야 한다면 단계에 따라 가장 속도가 빠른 L1캐시를 보고, 그 다음 L2캐시 그리고 메인메모리를 확인해서 값을 가져온다.
3. **메인메모리(RAM)** : 실제 운영체제와 다른 프로세스들이 올라가는 공간이다. 전원이 공급되지 않으면 데이터가 지워지기 때문에 휘발성 메모리이다. 하드디스크나 SSD보다 속도는 빠르지만 가격이 비싸기 때문에 실행중인 프로그램만 올린다.
4. **하드디스크** : 가격이 저렴하고 전원이 공급되지 않아도 데이터가 지워지지 않은 비휘발성 메모리이다.

## 7.2 메모리와 주소

여기서 말하는 메모리는 메인메모리이다. 멀티프로그래밍 환경에서 메모리에 여러 프로세스가 올라오니 메모리 관리가 필요하다. 운영체제는 메모리를 관리하기 위해서 1바이트 크기로 구역을 나누고 숫자를 매긴다. 이 숫자를 주소라고 한다.

![3](https://github.com/user-attachments/assets/aa6f8aa2-ba6d-4ede-85fa-000817d703e6)

### 물리주소와 논리주소

![4](https://github.com/user-attachments/assets/78e4dd13-25de-4d02-9fcf-06eae84ae183)

메모리를 컴퓨터에 연결하면 0x0부터 시작하는 주소공간이 있는데 이를 `물리주소공간`이라고한다.  그에 반해 사용자 관점의 주소공간을 `논리주소공간` 이라고 한다. 사용자는 물리주소를 몰라도 논리주소로 접근가능하다.

### 절대주소와 상대주소

사용자가 바라본 주소인 `상대주소`는 `논리주소공간` 이라고 부르고, 메모리 관리자가 바라본 주소인 `절대주소`는 `물리주소공간`이라고 부른다.

![5](https://github.com/user-attachments/assets/76c61ece-ac33-47c5-a70b-23d03e161e0a)

만약 사용자 100번지에 있는 데이터를 요청했을때, CPU는 메모리 관리자에게 100번지 주소를 가져오라고 요청하고 메모리 관리자는 재배치 레지스터에 있는 4000번지의 값을 더한  4100번지(절대주소, 물리주소)에 접근해 데이터를 가져온다.

재배치 레지스터에는 프로그램의 시작주소가 저장되어 있다. 따라서 메모리 관리자는 사용자가 메모리에 접근할 때마다 각 프로그램의 시작주소를 확인해 절대주소를 계산해 가져온다.

## 7.3 메모리 할당방식

멀티프로그래밍 환경에서의 메모리 할당 방식은 크게 2가지이다.

### 가변분할방식(세그멘테이션)

프로세스의 크기에 따라 메모리를 나누는 방식이다.

![6](https://github.com/user-attachments/assets/0709f05d-3bd8-4f4e-bf32-4309aaaf6e6b)

한 프로세스가 메모리에 연속된 공간에 할당되기 때문에 `연속 메모리 할당` 이라고도 한다. 장점으로는 연속되게 할당되기 때문에 더 크게 할당되서 낭비되는 공간인 `내부 단편화`가 없다. 단점으로는 `외부 단편화`가 발생한다.

**가변 분할 방식을 `세그멘테이션`이라고 한다.** `외부단편화`에 대해서 설명하자면, 다음과 같이 빈공간이 있지만 연속된 공간이 아니라서 프로세스를 할당할 수 없는 상태를 말한다.

![7](https://github.com/user-attachments/assets/b513dc2d-0d1a-4645-9aac-270877890a84)

이때 외부 단편화가 발생한 공간을 합쳐주는 `조각모음`을 하면 된다. 하지만 조각모음을 하려면 현재 실행되고 있는 작업을 일시 중지해야되고, 메모리 공간을 이동시키는 작업을 해야하기 때문에 오버헤드가 발생한다.

### 고정분할방식(페이징)

프로세스의 크기와 상관없이 메모리 정해진 크기로 나눈다.

![8](https://github.com/user-attachments/assets/82ff6bab-66da-457e-8d54-0ea7cfd0c553)

2MB로 분할된다고 가정하면 프로세스A는 구역 3개에 나눠서 할당된다. 그리고 1MB는 빈 공간으로 남는다. 프로세스C는 1MB에 할당되고, 1MB는 빈 공간으로 남는다. 이 방식은 한 프로세스가 메모리에 분산되어 할당되기 때문에 `비연속 메모리 할당` 이라고 한다. 장점으로는 구현이 간단하고 오버헤드가 적다. 단점으로는 공간이 낭비되는 `내부단편화` 가 발생한다.

가상 메모리 시스템에서 고정분할방식을 `페이징`이라고한다. 책의 페이지처럼 크기가 정해져 있다고 해서 붙은 이름이다.

![9](https://github.com/user-attachments/assets/620c940a-3691-4aa9-84b7-4e47f2defe30)

프로세스 A가 50MB가 필요하다고 가정했을 때 메모리 공간이 부족해 10MB는 하드디스크의 스왑영역에 할당됐다. 그리고 프로세스 C,D의 크기가 분할된 크기보다 작아서 낭비공간이 존재할때 이를 `내부단편화`라고 부흔다. 하지만 이를 해결하는 방법은 없고, 분할되는 크기를 조절해서 내부단편화를 최소화한다.

### 버디 시스템

버디 시스템은 가변분할방식와 고정분할방식을 혼합해 단점을 최소화한 방식이다. **버디 시스템은 2의 승수로 메모리를 할당한 방식이다.**

![10](https://github.com/user-attachments/assets/a024fd23-29bc-4e70-9b16-0bbb1ea637ef)

2의 승수로 500B보다 작은 수를 나눌때까지 나눈다.500B이 256B보다 크기 때문에 계산을 멈추고 512B크기의 공간에 프로세스를 할당한다. 이때 12B가 낭비되지만 즉 내부단편화가 발생하지만,  프로세스가 끝나고 메모리에서 나가도 근접한 공간을 합치기 쉽다. 그 이유는 2의 승수로 동일하게 나눠 조립만하면 큰 공간이 만들어지기 때문에 조각모음보다 훨씬 간단하다.

따라서 이 방식은 가변분할처럼 프로세스 크기에 따라 할당되는 메모리 크기가 달라지고, 외부단편화를 방지하기 위해 메모리 공간을 확보하는 것이 간단하다. 또한 고정분할방식처럼 내부단편화가 발생하지만 많은 공간의 낭비가 발생하지는 않는다.


출처 : [그림으로 쉽게 배우는 운영체제
](https://inf.run/Ciptb)