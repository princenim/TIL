# 2. 프로세스와 쓰레드

## 2.1 프로그램과 프로세스

`프로그램` : 어플리케이션이나 앱이라고 부르고, 윈도우에서는 .exe 파일의 모습을 하고있다.

`프로세스` : 하드디스크에 저장된 프로그램이 메모리에 올라가 실행중인 프로그램을 말한다. 프로세스의 영역은 다음과 같다. ( 프로세스가 메모리에 올라간다는 것은 밑의 각 영역이 메모리에 할당된다는 것을 의미)

- code 영역 : 자신을 실행하는 코드가 저장되어 있다.
- data 영역 : 전역변수와 static 변수가 저장되어 있다.
- stack 영역 : 지역변수, 함수 호출시 필요한 정보들이 저장되어 있다.
- heap 영역 : 프로그래머가 동적으로 메모리를 할당하는데 쓰인다.

그리고 프로세스는 운영체제의 의해 관리된다.

![1](https://github.com/user-attachments/assets/bfc1ccd4-bf3c-4f4b-83b1-56ad2fdbb58f)

CPU 입장에서 동작과정은 다음과 같다. CPU는 0과 1과 같은 기계어만을 실행하는데, CPU내의 제어장치가 숫자와 5와 7을 메모리에 저장시킨다. 그리고 이 메모리에 저장된 값을 레지스터(edx,eax)로 가져온다. 그리고 제어장치가 레지스터에 저장된 5와 7을 가지고 더하라는 명령을 하면 산술 논리 연산장치가 두 숫자를 더하고 그 결과인 12를 eax 레지스터에 저장한다. 그리고 다시 제어장치가 eax레지스터에 저장된 12을 가지고 메모리에 저장한다.

## 2.2 멀티프로그래밍과 멀티프로세싱

`유니프로그래밍` : 메모리에 프로세스가 1개인 상태

`멀티프로그래밍` : 메모리에 여러 개의 프로세스가 올라온 상태

즉, 유니프로그래밍과 멀티프로그래밍은 메모리의 몇개의 프로세스가 올라간 상태를 말한다.

`멀티프로세싱` : CPU의 관점으로 정의한 것. CPU가 여러개의 프로세스를 처리하는 것을 말한다.

따라서 멀티프로그래밍과 멀티프로세싱은 두 개가 공존한다. 메모리에는 여러 개의 프로세스가 올라오고, 시분할 처리로 CPU가 각각의 프로세스를 짧은 시간 동안 교대로 실행한다.

## 2.3 PCB

프로세스가 만들어지면 운영체제는 해당 프로세스의 정보를 가지고 있는 PCB를 만든다.  PCB는 연결리스트로 되어있어있다.

![2](https://github.com/user-attachments/assets/9c51bb0c-c880-46f8-bcfd-02c58cb8c3da)

PCB는 프로세스의 한 상태에서 다른 상태로 전환될때 저장하는 `포인터`를 가지고 있다.  `프로그램 카운터`는 프로세스를 어디까지 실행했는지 알고 있어야하기 때문에 원래 실행하던 명령어를 저장한다.

## 2.4 프로세스 상태

CPU는 한순간에는 하나의 프로세스밖에 처리하지 못한다. 다만 속도가 매우 빨라서 사람이 보기에 동시에 처리되는 것 처럼 보인다. 프 로세스는 다음과 같은 상태가 존재한다.

`생성상태(New)` : PCB를 생성하고 메모리에 프로그램 적재를 요청한 상태. 메모리에 프로그램 적재를 승인 받으면 준비상태로 넘어간다.

`준비상태(Ready)` : CPU를 사용하기 위해 기다리고 있는 상태로 CPU 스케줄러에 의해 CPU가 할당된다.

`실행상태(Running)` : 준비상태에 있는 프로세스가 CPU 스케줄러에 의해 CPU를 할당받아 실행되는 상태. 실행상태에 있는 프로세스의 수는 CPU의 개수만큼이다. 또한 CPU 스케줄러는 프로세스에 부여된 시간을 초과하면 할당된 CPU를 강제로 빼앗는다. 그럼 다시 준비상태로 들어간다.

`대기상태(Waiting)` : 프로세스가 입출력 요청을 하면 입출력을 완료될때까지 기다리는 상태이다. CPU는 굉장히 빠른장치인데 반해 입출력작업은 오래걸린다. 따라서 프로세스가 입출력 요청을 했을 때 작업이 완료될때까지 CPU가 대기하고 있는 것은 매우 비효율적이다. 따라서 입출력 요청을 한 프로세스를 대기상태로 두고, 다른 프로세스에게 CPU를 할당한다. 그리고 시간이 지나서 입출력 작업이 완료되면 대기 상태에 있던 프로세스에게 CPU 할당 기회를 준다.

`완료상태(Terminated)` : 프로세스가 종료된 상태. 프로세스가 사용했던 데이터를 메모리에서 제거하고, 사용한 PCB도 제거한다.

## 2.5 컨텍스트 스위칭

`컨텍스트 스위칭`은 프로세스를 실행하는 중에 프로세스의 상태를  저장하고, 다른 프로세스의 상태값으로 교체하는 작업이다. 실행중인 작업을 PCB에 저장하고, 실행될 프로세스의 PCB 내용대로 CPU가 다시 세팅된다.  컨텍스트 스위칭이 발생하는 이유는 다양하다. CPU 점유시간이 다 되거나, I/O 요청이 있거나, 다른 종류의 인터럽트가 있을 때 발생한다.

## 2.6 프로세스 생성과 종료

프로그램을 실행하면 운영체제의 해당 프로그램의 코드영역과 데이터 영역을 메모리에 로드하고, 빈 스택과 빈 힙을 만들어 공간을 확보한다. 그리고 PCB를 만들어 값을 초기화한다. 이 과정은 운영체제가 부팅되고 0번 프로세스가 실행될때 딱 한번 수행된다. 그리고 나머지 프로세스는 0번 프로세스를 복사해서 사용한다.이 프로세스들을 자식 프로세스라고 한다. 그리고 이 프로세스를 실행시키면 부모를 복사한 자식 프로세스의 코드와 데이터 영역을 원하는 값으로 덮어쓴다.

## 2.7 쓰레드

![3](https://github.com/user-attachments/assets/53c8a7a7-0d76-4cbe-9207-f1ea84c78d0a)

운영체제가 작업을 처리하는 단위는 프로세스이다. 쓰레드는 프로세스내에 존재하는 것으로 1개의 프로세스에 1개 이상이 존재할 수 있다. 그리고 스택을 제외한 코드, 데이터, 힙 영역을 공유한다. 그래서 쓰레드 ID도 부여하고, 이 쓰레드를 관리하기 위한 Thread Control Block(TCB)이 생겼다. 따라서 이제 운영체제가 작업을 처리하는 단위는 프로세스 내의 쓰레드이다.

프로세스는 안정적이다. 하나의 프로세스가 문제가 있어도, 다른프로세스는 영향을 받지 않는다. 하지만 쓰레드는 그 반대이다. 따라서 안정성 측면에서는 프로세스 방식이 더 우수하다. 속도와 자원에서는 쓰레드가 더 좋다. 쓰레드는 스택을 제외한 영역을 공유하기 때문에 오버헤드가 작고 빠르나, 프로세스는 IPC 통신을 해야하기때문에 오버헤드가 크고 속도가 느리다.


출처 : [그림으로 쉽게 배우는 운영체제
](https://inf.run/Ciptb)