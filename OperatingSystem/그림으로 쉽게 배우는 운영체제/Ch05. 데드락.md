# 데드락 

## 5.1 데드락 (feat. 식사하는 철학자)

여러 프로세스가 서로 다른 프로세스의 작업을 끝나기만을 기다리다가 아무 작업도 못하는 상태를 `교착상태(데드락)`라고 한다. 만약 여러 개의 자원을 프로세스가 공유하지 않는다면 교착상태는 발생하지 않는다.

### 식사하는 철학자

![2](https://github.com/user-attachments/assets/ddc43c34-e399-4cfc-ad8e-f6cb44ae4eaa)

만약 포크가 3개있고, 음식을 먹으려면 한 사람당 포크가 2개가 필요하다. 만약  모든 철학자가 오른쪽의 포크를 사용하고 포크가 각 하나 더 필요할때 아무도 양보를 하지 않는 다면 더 이상 식사가 불가능한 `교착상태에` 빠진다.

교착상태의 필요조건은 다음과 같다. **4가지 중에 한가지라도 충족하지 않는다면 교착상태는 발생하지 않는다.**

1. **상호배제** - 식사하는 철학자에서 포크가 이에 해당된다. 먼저 포크를 집었다면 그 포크는 다른 사람이 사용할 수 없는 리소스이다.
2. **비선점** : 프로세스 A가 리소스를 선점하고 있을때 프로세스B가 리소스를 빼앗길 수 없어야 한다. - 식사하는 철학자에서 철학자 A의 포크를 철학자 B가 뺏을수 없다.
3. **점유와 대기** : 어떤 프로세스가 리소스A를 가지고 있는 상태에서 리소스B를 원하는 상태여야 한다. - 식사하는 철학자에서 오른쪽 포크를 가진 상태에서 왼쪽 포크를 원하는 상태이다.
4. **원형대기** : 점유와 대기를 하는 프로세스들의 관계가 원형을 이루고 있다. - 식사하는 철학자에서 서로가 서로의 포크를 원하는 상황이 원형을 이룬다.

![3](https://github.com/user-attachments/assets/86b95ac4-fbf2-4209-b9b7-a3276e1971c1)

## 5.2 데드락 해결 (feat. 은행원 알고리즘)

교착상태 해결방법으로 `교착상태 회피(Deadlock avoidance)`라는 방법이 있다. 프로세스에게 자원을 할당할 때 어느정도 자원을 할당해야 교착상태에 발생하는지 파악해서 교착상태가 발생하지 않을만큼 자원을 할당한다.

교착상태 회피는 전체 자원의 수와 할당된 자원의 수를 기준으로 `안정상태`와 `불안정상태`로 나눈다. 그리고 운영체제는 안정상태를 유지하려고 최대한 자원을 할당한다.

![4](https://github.com/user-attachments/assets/9e19ff14-a426-491a-886b-bac32f28a400)

은행은 돈을 못 받는 상황을 막기 위해서 돈을 빌려줄 때 은행의 여윳돈과 사업자들에게 빌려준 돈들을 보고 대출가능한 상황(안전상태)인지 확인하고 빌려주는데 이를 `은행원 알고리즘`이라고 한다.

![5](https://github.com/user-attachments/assets/bb9cbd43-5b20-45bb-9512-66d97f9e6358)

만약 P1이 4개를 요청하면 현재 사용 가능한 자원은 2개이기 때문에 요청을 거절하고 P2에게 2개 자원을 제공한다. 그리고 P2는 할당된 자원을 가지고 작업을 마치고 6개를 반납한다. 그럼 사용가능한 자원이 들어났기 때문에 P1과 P3의 요청을 전부 제공할 수 있다.

![6](https://github.com/user-attachments/assets/07fd6c1b-b908-47e0-92a3-bcf3ddcb32ac)

사용 가능한 자원이 1개일때 P1,P2,P3가 요청할 수 있는 자원을 제공할 . 수없다. 이를 `불안정상태`라고 한다.

은행원 알고리즘은 교착상태를 피하는 좋은 방법이지만 비용이 비싸고 비효율적이다. **따라서 교착상태를 피하는 방법보다 교착상태가 발생했을 해결하는 방식을 연구했다.**

1. `가벼운 교착상태 검출`: 타이머를 이용하는 방식으로 프로세스가 일정시간 동안 작업을 진행하지 않는다면 교착상태가 발생했다고 간주하고 교착상태를 해결한다. 일정 시간마다 체크포인트를 만들어 상태를 저장하고 타임아웃으로 교착상태가 발생하면 마지막으로 저장했던 체크포인트로 롤백한다.
2. `무거운 교착상태 검출` : 이 방식은 ‘자원 할당 그래프’를 이용하는데 현재 운영체제에서 프로세스가 어떤 자원을 사용하는지 지켜보고 교착상태가 발생하면 해결한다.

![7](https://github.com/user-attachments/assets/33a7f311-11ba-4664-ab52-2124debbbd31)

왼쪽은 순환구조가 생기지 않기때문에 교착상태가 발생하지 않는 그래프이고, 오른쪽은 순환구조로 교착상태가 발생할 그래프이다.  이렇게 교착상태를 검출했다면 교착상태를 일으킨 프로세스를 강제종료한다. 그리고 다시 실행시킬 때 체크포인트로 롤백 시킨다. 하지만 이 방식은 운영체제가 지속적으로 자원할당그래프를 유지하고 검사해야하기 때문에 오버헤드가 발생한다. 하지만 가벼운 교착상태 검출에서 발생할 수 있는 억울하게 종료되는 프로세스 종료는 발생하지 않는다.