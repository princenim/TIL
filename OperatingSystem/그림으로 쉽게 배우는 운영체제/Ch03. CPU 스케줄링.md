# 3. CPU 스케줄링

## 3.1 CPU 스케줄링 개요

프로그램을 실행시키면 메모리에 프로세스가 생성되고, 각 프로세스에는 쓰레드가 1개 이상 존재한다.  프로세스는 CPU를 차지하기 위해서 운영체제의 명령을 기다린다. 즉 운영체제는 모든 프로세스에게 CPU를 할당/해제 하는데 이를 `‘CPU 스케줄링’`이라고 한다.

CPU 스케줄링을 위해서는 2가지를 고려해야한다.

1. 어떤 프로세스에게 CPU 리소스를 줘야하는가?
2. CPU리소스를 할당받은 프로세스가 얼마의 시간동안 사용해야하는가?

위 2가지 고려사항이 컴퓨터의 성능에 큰 영향을 미치고, CPU에게 할당받아 실행하는 작업을 `‘CPU Burst’`라고 하고, 입출력 작업을 `I/O Burst`라고 부른다.

## 3.2 다중큐

![1](https://github.com/user-attachments/assets/bb5ae584-6695-40f5-85ce-bff3c8399a05)

실행상태에 있는 프로세스는 CPU할당 시간이 다 됐다면, 실행상태 →  준비상태로, I/O 요청이 있다면 실행상태 → 대기상태로, 작업이 끝났다면 실행상태 → 완료상태로 전환된다. 여기서 프로세스가 대기하고 있는 준비상태와 대기상태는 ‘큐’로 관리된다.  프로세스가 실행상태에서 준비상태로 돌아갈때, 운영상태는 그에 맞는 ‘준비 큐’에 넣는다.

![2](https://github.com/user-attachments/assets/ca2e5dbc-9561-4e09-a92f-1105cf8ce710)

그리고 운영체제는 ’준비상태의 다중큐’에 들어있는 프로세스들 중에 적당한 프로세스를 선택해서 실행상태로 전환시킨다.

![3](https://github.com/user-attachments/assets/a3d15879-2db6-42b7-9c77-6c8e47497b95)

만약 실행상태에서 I/O요청을 받아 대기상태로 오게되면 I/O 작업 종류에 따라서 분류된 큐에 들어가게 된다. 예를 들면 하드디스크 작업은 HDD 큐에 들어가고,  하드디스크 작업이 완료되어 인터럽트가 발생하면 HDD 큐를 뒤져서 다시 꺼내간다.

![4](https://github.com/user-attachments/assets/d840d6ba-bcee-4b40-84ae-7fdd3c91ae35)

정확히는 프로세스의 정보를 가지고 있는 PCB가 들어간다.

정리하면 프로세스의 정보를 담고 있는 PCB는 준비상태의 다중큐에 들어가서 실행되기를 기다리고 있고, CPU 스케줄러에 의해 실행상태로 전환된다. 이때 CPU 스케줄러는 준비상태의 다중큐를 참고해서 어떤 프로세스를 실행시킬지 결정한다. I/O 작업도 비슷하다. 만약 프로세스 실행중에 I/O 작업이 발생하면 해당 I/O 작업의 종류별로 나뉜 큐에 들어가고, CPU 스케줄러는 이를 참조해 스케줄링을 한다.

## 3.3 스케줄링 목표

1. 리소스 사용률
2. 오버헤드 최소화
3. 공평성
4. 처리량
5. 대기시간 : 대기하는 시간을 짧은 것을 목표로 함
6. 응답시간

## 3.4 FIFO

`First In First Out`으로 먼저 들어온 작업이 먼저 나간다. 이 방식은 먼저 들어온 프로세스가 먼저 나가야 다음 프로세스가 실행될 수 있다. 직관적이나 한 프로세스가 끝나야 다음 프로세스가 끝나기 때문에 늦게 들어온 프로세스는 기다려야한다. 또한 I/O 작업이 들어온다면 CPU는 I/O 작업이 끝날때까지 쉬고있기 때문에 CPU 사용률이 떨어지게 된다.

스테줄링의 성능은 평균 대기 시간으로 평가한다. 평균 대기 시간은 프로세스 여러개가 실행될 때 이 프로세스들 모두가 실행되기 때까지의 대기시간의 평균을 말한다. FIFO 알고리즘은 Burst time(프로세스 실행시간)따라 성능의 차이가 심하게 나기때문에 현대 운영체제에서 잘 쓰이지 않는다.

## 3.5 SJF (shortest job first)

짧은 작업 먼저 실행한다. 이론적으로는 FIFO보다 성능이 더 좋으나 문제가 있다.

1. 어떤 프로세스가 얼마나 실행될지 예측하지 힘들다.
2. Burst time이 긴 프로세스는 오랫동안 실행되지 않을 수도 있다. 즉 Burst time이 짧은 프로세스를 계속 먼저 실행되기 때문에 Burst time이 긴 프로세스는 실행이 되지 않아 불공평하게 느껴질 수 있다.

따라서 이런 문제때문에 사용하지 않는다.

## 3.6 RR (Round Robin)

FIFO 알고리즘의 단점은 먼저 들어온 프로세스가 끝나야 다음 프로세스가 실행된다는 점이다. 이를 해결하기 위한 방법이 RR이다.

프로세스에게 일정 시간만큼 CPU를 할당하고, 할당된 시간이 지나면 강제로 일정시간만큼 CPU를 할당한다. 그리고 강제로 CPU를 뺏긴 프로세스는 큐의 가장 뒷부분으로 밀려난다.

프로세스에게 할당하는 일정시간은 타임 슬라이스 또는 타임 퀀텀이라고 부른다. 라운드 로빈 알고리즈은 컨텍스트 스위칭이 있기때문에 컨텍스트 스위칭 시간이 추가되어야한다. 그리고 라운드 로빈은 타임슬라이스에 따라 성능이 많이 달라진다. 따라서 최적의 타임슬라이스를 잘 찾아야한다. 실제로 윈도는 타임슬라이스가 20ms, 유닉스는 100ms이다.

## 3.7 MLFQ (Multi Level Feedback Queue)

MLFQ는 오늘날 가장 많이 쓰이는 CPU 스케줄링 알고리즘이다. MLFQ은 라운드 로빈이 업그레이드된 방법이다.

![5](https://github.com/user-attachments/assets/e481cc6e-e391-420d-8956-a1c80d1edfd9)

MLFQ은 기본적으로 CPU 사용률과 I/O 사용률이 좋게 나오는 타임 슬라이스가 적은 방법을 선택한다. 그리고 CPU Bound Process에게는 타임슬라이스를 크게준다. 이때 CPU Bound Process와 I/O Bound Process 를 운영체제는 알 방법은 사용을 하다가 CPU 사용량이 많으면 CPU Bound Process라고 판단한다.

![6](https://github.com/user-attachments/assets/05f3879e-651e-4b3f-9b8f-25bb907c5b6f)

이러한 아이디어를 기반으로 여러개의 우선순위 큐를 준비한다. 우선순위가 높으면 타임슬라이스가 적다. 만약 P1처럼 타임슬라이스 크기를 오버해서 강제로 CPU를 뺏긴다면 P1은 원래 있던 큐보다 우선순위가 더 낮은 큐로 이동한다.

추가로 I/O 작업이 발생하면 하드웨어 장치가 작업을 처리하는 동안 CPU는 다른 프로세스를 처리한다. I/O작업이 요청된 프로세스는 대기상태로 전환되고, 이때 I/O작업이 끝나면 인터럽트가 발생되어 CPU에게 작업이 끝났음을 전달한다. 그리고 운영체제는 대기상태에 있던 프로세스를 준비큐에 넣는다.

출처 : [그림으로 쉽게 배우는 운영체제
](https://inf.run/Ciptb)