# 8. 가상메모리

## 8.1 가상메모리 개요

**프로세스는 메모리관리자를 통해 메모리에 접근한다.** 메모리 관리자는 프로세스의 요청이 있으면 그에 맞는 물리메모리로 연결시켜준다. `가상메모리`의 크기는 이론적으로는 무한대이지만 실제로는 물리 메모리 크기와 CPU 비트 수로 결정된다. 만약 32bit CPU인 경우 표현할 수 있는 주소값은 2의 32승으로 대략 4GB정도이고, 가상메모리 크기도 똑같이 4GB이다.

![1](https://github.com/user-attachments/assets/7842151c-eb16-4cdf-b0f7-87ec1c79fcd8)

4GB를 차지하는 프로세스 5개와 운영체제를 실행시킨다고 가정해보자. 운영체제를 제외하더라도 프로세스만 20GB가 필요하고 턱없이 부족하다.

![2](https://github.com/user-attachments/assets/e64b057b-d552-4d1e-886e-1d26d461730e)

이때 가상메모리 시스템은 물리메모리 내용의 일부를 하드 디스크에 있는 스왑영역으로 옮기고, 처리가 필요할때 물리메모리로 가져와 실행시키기 때문에 운영체제와 프로세스 5개를 전부 실행시킬 수 있다.

![3](https://github.com/user-attachments/assets/34937245-c645-4c28-b10e-5357b27b3a00)

메모리 관리자는 프로세스가 사용하는 가상주소를 물리주소로 변환하는데 이것을 `동적주소변환(Dynamic Address Translation)`이라고 한다. 즉 DAT를 거치면 프로세스는 마음대로 사용자 데이터를 물리 메모리에 배치할 수 있다.

![4](https://github.com/user-attachments/assets/f19d527f-665f-4256-a395-30fc04e88459)

가상메모리시스템에서는 운영체제 영역을 제외한 나머지 영역을 일정한 크기로 나누어서 프로세스에게 할당하는데 할당하는 방식은 메모리 분할방식과 마찬가지로 `가변분할방식(세그멘테이션)`와 `고정분할방식(페이징)`으로 나뉜다.

세그멘테이션은 외부 단편화와 같은 단점이 있고, 페이징은 내부 단편화같은 단점이 존재한다. 따라서 이 단점을 보완한 `세그멘테이션-페이징` 혼용기법을 사용한다.

![5](https://github.com/user-attachments/assets/b3a3f02c-bec1-4451-af55-b9692fba97ff)

메모리 관리자는 가상주소와 물리주소를 일대일 매핑테이블로 관리한다. 매핑테이블을 보면 프로세스A는 세그먼트0에 위치하고, 프로세스B는 세그먼트1에 존재한다.

## 8.2 세그멘테이션(배치정책)

사용자와 프로세스, CPU가 바라보는 주소는 논리주소이다. 이때 메모리관리자(MMU)는 논리주소를 실제 물리주소로 변환해준다. **그럼 메모리 관리자는 어떻게 논리주소를 물리주소로 변환할까?**

![6](https://github.com/user-attachments/assets/9e55eab1-04f5-4c2b-86d0-410803a01bbd)

메모리관리자는 `세그멘테이션 테이블`이라는 것을 갖고있다. 세그멘테이션 테이블에는 `Base Address`와 `Bound Address`가 저장되고 이를 통해 메모리관리자는 물리 메모리 주소를 계산한다.

![7](https://github.com/user-attachments/assets/7ac1f467-c218-45fe-b6e1-b97313edab2f)

![8](https://github.com/user-attachments/assets/a2f6b97c-33a1-47c7-96d1-28c0c328d1d8)

CPU에서 논리주소를 전달하면 메모리관리자는 이 논리주소가 ‘몇번’ 세그먼트인지 알아낸다. 그리고 메모리관리자는 메모리관리자 내의 `Segment Table Base Register`를 이용해서 물리 메모리내에 있는 `세그멘테이션 테이블`을 찾고, 세그먼트 번호를 인덱스로 `Base Address`와 `Bound Address`를 찾는다.

참고로 컨텍스트 스위칭을 할때마다 메모리 관리자 내의  `Segment Table Base Register` 를 해당 프로세스의 것으로 바꿔줘야한다. 따라서 컨텍스트 스위칭은 매우 무거운 작업이다.

`Bound Address`는 세그먼트의 크기를 나타낸다. 메모리관리자는 CPU가 보낸 논리주소와 Bound Address의 크기를 비교한다. 만약 논리주소가 Bound Adress의 주소보다 작다면 논리주소와 Base Address를 더해 물리주소를 구하고, 논리주소가 Bound Address보다 크다면 메모리를 침범했다고 판단 예외를 발생시킨다.

CPU에서 세그먼트1번이 0x632번지로 접근한다고 가정해보자. 메모리 관리자는 CPU의 요청을 받고 세그먼트1번인것을 알아낸다. 그리고 메모리 관리자내의 `Segment Table Base Register` 를 이용해서 세그멘테이션 테이블을 찾아낸다. 그리고 세그먼트1번이 위치한 1번 인덱스를 참조한다. 논리주소 632와 Bound Address 1000을 비교하니 논리주소가 더 작다. 그럼 논리주소632와 Base Address 5200을 더해 5382가 나오고 최종주소가 물리주소 0x5832로 성공적으로 변환된다.

## 8.3 페이징(배치정책)

세그멘테이션은 외부단편화( = 메모리 사이에 중간중간 사용하지 않은 작은 메모리가 생겨 할당 공간이 부족하여 발생하는 상황) 문제가 있기때문에 이를 해결하기 위해 나온 방법이 페이징이다.

페이징은 메모리를 할당할 때 정해진 크기의 페이지로 나눈다. 모든 페이지는 크기가 같기때문에 관리가 굉장히 쉬워진다. 또한 일정한 크기로 나눴기 때문에 외부단편화 현상이 일어나지 않는다. 즉 대신 내부단편화가 일어난다.

![9](https://github.com/user-attachments/assets/237932fd-a735-4a6b-97dc-0ae8f894e22a)

페이징에서 논리주소공간은 일정한 크기로 균일하게 나뉜다. 이를 `페이지`라고 한다. 물리주소공간도 동일하게 나뉘는데 이를 `프레임`이라고 한다.

**그럼 페이징의 주소변환을 어떻게 할까?**

![10](https://github.com/user-attachments/assets/f56a18ec-16fa-4451-b993-14f9712bae25)

세그멘테이션과 마찬가지로 메모리 관리자는 `페이지 테이블`을 가지고 있다. CPU에서 논리주소를 전달하면 메모리 관리자는 이 논리주소가 몇번 페이지인지 오프셋은 얼마인지 알아낸다. 그리고 메모리 관리자 내의 `Page Table Base Register`  를 활용해서 물리 메모리에 있는 페이지 테이블을 찾고, 페이지 번호를 인덱스로 프레임번호를 알아내고 오프셋을 이용해 물리주소로 변환한다. 오프셋은 계산을 통해 쉽게 구할 수 있는데 페이지 테이블에 Invalid로 표시되어 있으면 스왑영역 즉 하드디스크에 저장되어있다는 의미이다. 세그멘테이션과 마찬가지로  `Page Table Base Register` 은 운영체제가 컨텍스트 스위칭을 할 때마다 해당 프로세스의 것으로 업데이트 해준다.

**그렇다면 32bit CPU가 어떻게 주소변환을 할까?**

![11](https://github.com/user-attachments/assets/747f9234-b0b1-410c-9ad4-ad0d0ced6dfc)

32bit CPU의 가상 메모리 크기는 2의 32승으로 대략 4GB이다. 따라서 이 4GB의 가상메모리를 2의 24승의 대략 16MB의 페이지로 나눈다고 가정해보자. 그럼 32bit중에 24bit는 페이지 크기를 나타내고, 나머지 8bit는 페이지 번호를 나타낸다. 페이지 번호는 2의 8승이므로 총 256개의 페이지가 존재한다.

![12](https://github.com/user-attachments/assets/e9e5c8a2-bd1d-4458-b08d-76e3924ff890)

페이지 0은 0~16777216번지로 구성된다. 이제 물리주소공간도 가상주소의 페이지 크기와 동일한 16MB로 나눠준다.  물리주소의 프레임은 128개로 2GB정도밖에 안되게 가정한다.  이는 물리주소의 크기가 가상주소의 크기보다 작아도 문제가 없음을 보여주기 위한 것이다. 부족한 물리메모리는 스왑처리를 하기때문에 괜찮다.

메모리관리자 내의 페이지 테이블은 1차원 배열로 구성되어있는데 페이지번호가 배열의 인덱스가 된다. 즉 해당 인덱스로 가면 프레임을 얻을 수 있다. 이제 여기서 CPU가 논리주소 0x1000번지에 접근한다고 가정해보자. 페이지 넘버를 구하는 공식은 다음과 같다. `페이지 넘버 = 논리주소/페이지 크기`  즉, 1000번지의 페이지 넘버는 1000/ 16777216로 0이다. 오프셋을 구하는 공식은 `오프셋 = 논리주소 % 페이지 크기` 으로 1000번지의 오프셋은 1000 % 16777216로 1000이다.

![13](https://github.com/user-attachments/assets/56cf988b-a143-46e3-9b87-aca58caf7057)

이제 페이지 넘버와 오프셋을 구했으니 페이지 넘저를 페이지 테이블의 인덱스로 참조할 수 있다. 0번 인덱스의 프레임번호가 3번이니 프레임 3번 위치에서 오프셋 1000을 더하면 실제물리주소를 구할 수 있다.

### 세그멘테이션과 페이징의 차이점

![14](https://github.com/user-attachments/assets/c5448e25-8a4e-4fc9-8a0b-3d9ac6225ff3)

1. 페이지의 크기 : 세그멘테이션은 프로세스마다 크기가 달라 Bound Address를 가지고 있지만, 페이징은 모든 페이지의 크기가 동일해서 크기를 표현하는 Bound Address는 필요하지 않다. 따라서 페이징은 외부단편화는 발생하지 않지만 내부 단편화가 발생한다. 정해진 크기의 페이징보다 프로세스의 정보가 작으면 공간이 낭비되는데 이를 내부 단편화라고 한다. 하지만 많은 공간이 낭비되는것이 아니기 때문에 심각하게 생각하지 않는다.
2. 세그멘테이션은 논리적은 영역별로 세그먼트를 나눈다. 따라서 코드,데이터, 스택,힙 영역으로 나눌 수 있다. 하지만 페이징은 페이지의 크기가 고정되어 있어 논리적인 영역을 나눌 수 없다. 따라서 페이징에서는 페이지 테이블 크기를 가장 신경써야한다. 각 프로세스마다 페이지 테이블을 가지고 있는데 프로세스가 많아질수록 이 페이지 테이블이 많아지기 때문에 프로세스가 사용할수 있는 영역이 줄어든다.

## 8.4 페이지드 세그멘테이션(배치정책)

`페이지드 세그멘테이션`은 `세그멘테이션`과 `페이징`을 혼합해 장점을 취한 방식이다. 세그멘테이변은 가변분할방식이라서 코드,힙, 데이터 영역을 세그먼트로 나눠서 관리할 수 있다. 따라서 다른 프로세스와 공유하기도 편하고 각 영역에 대한 메모리 접근보호를 하기가 쉽다. 반면에 페이징은 고정분할방식으로 메모리를 효율적으로 관리할  수 있다.

### 메모리 접근 권한

![15](https://github.com/user-attachments/assets/f10570e5-9a5a-489c-8e23-79ef8c77978d)

메모리 접근 권한은 메모리의 특정 번지에 부여된 권한으로 읽기(Read), 쓰기(Write), 실행(Execute) 3가지가 존재한다. 프로세스는 코드,데이터,스택,힙 영역이 존재하는데 각 영역마다 접근권한이 있다. 코드영역은 읽기/실행 권한, 데이터 영역은 읽기와 쓰기는 있거나 없거나 이다. 그리고 힙과 스택 영역은 읽기/쓰기 권한이 존재한다. 이 메모리 접근 권한의 검사는 논리주소에서 물리주소로 변환될 때 일어나는데 권한 위반이 발생하면 에러가 발생한다.

![16](https://github.com/user-attachments/assets/4c51342b-b02e-4998-9003-afd9e9c7b303)

이제 `페이지드 세그멘테이션` 을 설명해보면 `페이지드 세그멘테이션` 기법에서는 세그멘테이션 테이블에 권한 비트를 추가한다. 그리고 Base Address는 페이지 넘버로 바뀌고, Bound Address는 이 세그먼트의 페이지 개수로 바뀐다.

![17](https://github.com/user-attachments/assets/3c7f1770-70e1-44df-aea8-868e2f17e528)

만약 논리주소 0x12300이 들어오면

1. 메모리 관리자는 해당 주소에서 세그먼트 번호를 알아낸다. 그리고 테이블을 가져와  세그멘테이션 테이블의 1번 인덱스를 참조한다.
2. 그리고 해당 세그먼트가 메모리 접근 권한을 위반하는지 확인한다. 해당 세그먼트의 권하는 RE이므로 만약 접근권한을 위반하면 프로세스를 종료 아니라면 페이지넘버와 페이지 개수를 가져온다.
3. 페이지 넘버로 페이지 테이블을 접근해서 프레임 번호를 가지고 오고, 물리 메모리의 3번 프레임 위치임을 알아낸다. 이제 프레임 3에서 페이지 개수1000을 더하면 물리주소이다. 만약 프레임3의 메모리가 없다면 스왑영역에서 물리메모리로 가져온다.

![18](https://github.com/user-attachments/assets/2b3a624b-fedc-4318-907b-f8f94481d9b0)

이렇게 페이지드 세그멘테이션의 단점은 메모리에 접근을 2번해야 된다는 점이다. 처음에 세그멘테이션을 참조할때, 두번째는 페이지 테이블을 참조할때이다.이렇듯 현대 운영체제에서는 페이징과 페이지드 세그멘테이션 기번을 적절히 섞어서 사용한다.
