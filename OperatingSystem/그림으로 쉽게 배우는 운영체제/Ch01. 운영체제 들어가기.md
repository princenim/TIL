# 1. 운영체제 들어가기

## 1.1 운영체제 개요

컴퓨터는 운영체제 없어도 동작 가능하다.  그러나 운영체제가 없으면 설계한 그대로의 기능만 사용가능할 뿐 유연하지 못한다. 

### 운영체제가 하는일

1. 프로세스 관리
2. 메모리 관리- 모든 프로그램은 메모리에 올라가서 실행
3. 하드웨어 관리 - 운영체제가 판단해 데이터를 저장
4. 파일 시스템 관리 

## 1.3 운영체제 구조

운영체제의 핵심은 커널으로, 커널을 프로세스와 메모리,저장장치를 관리하는 역할을 한다. 사용자는 커널에 직접 접근할 수 없고 인터페이스를 통해 접근 가능하다. 인터페이스에는 GUI와 CLI가 존재한다. 

![1](https://github.com/user-attachments/assets/a6ed6ce3-16c8-49e0-9e7c-4053686f49a7)

GUI는 그래픽으로 된 인터페이스, CLI 는 유닉스나 리눅스 같은 운영체제가 제공하는 인터페이스를 말한다. 

![2](https://github.com/user-attachments/assets/91b91596-f2fc-4d94-993a-66576130063f)

어플리케이션은 시스템 콜을 통해서 커널에 접근할 수 있다. 커널은 사용자로부터 자신을 보호하기 위한 `시스템 콜`이란 인터페이스를 가지고 있다. 시스템콜을 이용하면 커널에서 제공하는 write 함수를 사용하는데 그럼 운영체제가 알아서 하드디스크의 빈 공간에 저장한다. 

![3](https://github.com/user-attachments/assets/86de07c3-3847-4f9c-b488-3e0f738f45b7)

하드웨어와 커널의 인터페이스로는 드라이버를 사용한다. 운영체제는 많은 종류의 하드웨어를 전부 지원해야하기 때문에 각각의 하드웨어에 맞는 프로그램을 커널이 전부 가지고 있기 힘들다. 그래서 하드웨어를 제조한 제조사에서 드라이버를 제공한다. 보통 키보드나 마우스 같은 간단한 장치들은 커널에 포함되어 있어 컴퓨터에 꽂으면 바로 동작하지만, 그래픽카드같은 복잡한 장치는 드라이버를 설치해서 사용해야한다. 

## 1.4 컴퓨터 하드웨어와 구조

CPU와 메모리를 두고 이 사이를 버스로 연결한다. 버스는 데이터를 전달하는 통로를 말한다. 

![4](https://github.com/user-attachments/assets/35f119b0-2b07-45e7-8bad-69fc58abd1ed)

메인보드 (다른 하드웨어를 연결하는 장치)에 다음의 하드웨어를 연결한다. 

- CPU와 메모리
- 하드디스크
- 그래픽카드
- 모니터
- 마우스,키보드
- 스피커

### CPU(Central processing unit, 중앙 처리 장치)의 구조

![5](https://github.com/user-attachments/assets/f0a6d964-16c4-469c-a0c8-9d44d951715c)

CPU를 구성하는 장치는 3가지로 나뉜다. 

1. 산술논리 연산장치 : 실제로 데이터 연산을 담당
2. 제어장치 : 모든 장치들의 동작을 지시하고 제어 
3. 레지스터 : CPU 내에서 계산을 위해 임시로 보관하는 장치 e.f. 변수

### 메모리 종류

![6](https://github.com/user-attachments/assets/c03127b0-fcb9-4eb0-a635-da7f53a0253f)

1. `RAM(Random Access Memory)` : 랜덤으로 데이터를 읽어도 저장된 위치와 상관없이 읽는 속도가 같다. 전력이 끊기면 데이터를 잃어버리기 때문에 메인 메모리로 사용한다. 
2. `ROM(Read Only Memory)` : 전력이 끊겨도 데이터를 계속 보관할 수 있지만 데이터를 한번쓰면 수정이 불가능. 그래서 컴퓨터의 부팅과 관련한 바이오스를 저장하는데 쓰임

## 1.5 컴퓨터의 부팅과정

1. 전원 버튼을 누른다. 
2. ROM에 저장된 바이오스가 실행. 바이오스는 전원,CPU,메모리, 키보드, 마우스, 하드디스크 등 주요 하드웨어에 이상이 없는지 체크한다.
3. 이상이 없다면 하드디스크에 있는 마스터부트레코드에 저장된 부트로더를 메모리에 가져와 실행한다. 
4. 운영체제를 불러오고 모니터에 바탕화면이 보인다.
5. 후에 실행되는 모든 응용 프로그램은 메모리에 올라가 운영체제가 관리한다. 

## 1.6 인터럽트

![7](https://github.com/user-attachments/assets/c13ef6f7-38c0-4db7-85ec-b0b594c66475)

CPU는 입출력이 들어오면 입출력 관리자에게 명령을 내린다. CPU에서는 언제 입출력이 완료되는지 모르기 때문에 주기적으로 확인해야한다. 이러한 방식을 `Polling(폴링)` 방식이라고 한다. 이 방식은 주기적으로 CPU가 확인해야하니 성능이 좋지 않다. 

인터럽트는 폴링 방식의 단점을 해결한 방식이다. **CPU가 입출력 관리자에게 명령을 내리고 자기는 다른 작업을 한다.** 그리고 입출력관리자는 작업이 완료되면 CPU에게 알리고, CPU는 ‘신호’를 받아 `인터럽트 서비스 루틴(ISR)`을 실행시켜 작업을 완료한다. ISR은 특정 인터럽트가 들어오면 그 인터럽트를 처리하는 함수이다. 인터럽는 비동기적으로 동작하기 때문에 성능에 이점이 있다. 

![8](https://github.com/user-attachments/assets/c858ffa2-b088-4d0e-8646-3e6ce6a746dc)

인터럽트는 하드웨어 방식과 소프트웨어 방식 2개가 존재한다. 위의 방식은 하드웨어 방식이고,  소프트웨어 방식은 사용자 프로그램에서 발생한 인터럽트를 말한다. 예를 들면 유효하지 않은 메모리에 접근하거나, 0으로 나누는 명령어가 있다.



출처 : [그림으로 쉽게 배우는 운영체제
](https://inf.run/Ciptb)