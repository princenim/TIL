# 📌 동기와 비동기 / 블로킹과 논블로킹의 차이

# 1. 동기와 비동기

`동기와` `비동기`의 차이는 내가 API 호출을 했을 때 이 그 “결과”를 누가 처리하느냐에 따라서 다르다. **만약에  내가 호출하고 내가 처리하면 `동기`,  내가 호출하고 결과를 다른 쓰레드가 처리하면 `비동기`다.** 그래서 대표적인 비동기의 예시가 메세지 큐에 메세지를 넣어넣고 나는 다른 일을 하는 것이다.

## 1.1 동기(Synchronous)

내가 호출하고 내가 처리하면 `동기(Synchronous)`이다. 만약 두개의 쓰레드가 존재할때 A쓰레드와 B쓰레드가 각각 자기의 작업을 진행하면 그것도 동기이다.  즉 동기 프로그래밍은 자기의 일을 순차적으로 실행한다.

따라서 프로그램의 흐름을 이해가 쉬우나 하나의 작업이 끝날때까지 다른 작업을 처리하지 못하므로 전체 프로세스가 느려질 수 있다.
(동기는 요청의 결과를 기다린다.)

## 1.2 비동기 (Asynchronous)

내가 호출하고 다른 쓰레드가 처리하면 `비동기(Asynchronous)`이다. 요청한 쓰레드와 처리하는 쓰레드가 다르면 비동기이다. 따라서 내가 작업을 호출한 후에 다른 쓰레드가 작업을 처리하면 나는 다른 작업을 처리할 수 있다.

따라서 비동기 프로그래밍은 코드의 여러 작업을 동시에 처리할 수 있어 전체적인 성능이 향상된다. 하지만 코드의 복잡성이 증가한다.
(비동기는 요청의 결과를 신경쓰지않는다.)

### 동기 / 비동기 예시

유튜브를 업로드할때를 생각해보자. 동영상을 업로드하면 동영상은 업로드를 하고, 인코딩하는 과정을 거쳐야한다. 그리고 사용자는 인코딩을 할때 다른 작업을 수행할 수 있다. 이렇게 내가 동영상 업로드하고 응답을 받는 행위 자체는 `동기`, 동영상을 인코딩 하는 과정이 `비동기`이다. 똑같은 예시로 카카오톡에서 동영상을 다른 사람에게 보내도 메세지를 보낼 수 있는 것도 비동기작업이다.

# 2. 블로킹과 논블로킹

**블로킹은 어떤 작업이 실행되는동안 내가 다른 일을 못하면 블로킹이고, 다른 작업을 할 수 있으면 논블로킹이다.**

## 2.1 블로킹(blocking)

블로킹은 어떤 작업이 실행되는 동안 해당 작업이 완료될때까지 내가 다른 작업을 수행하지 못하는 상태를 의미한다. 즉 한 쓰레드가 작업을 수행할때 다른 쓰레드는 작업을 수행하지 못하고 대기하게 된다.

## 2.2 논블로킹(non-blocking)

논블로킹은 어떤 작업이 진행중이더라도 내가 다른 작업을 수행할 수 있는 상태를 의미한다. 한쓰레드에서 작업이 진행되어도 다른 쓰레드에서 작업을 수행할 수 있는 상태를 말한다.

### 블로킹 / 논블로킹 예시

`InputStream`의 `read()`는 블로킹이다. 입력을 다 받기전까지 다른 작업을 수행할 수 없으므로 `블로킹`이다. 그리고 `BufferedReader` 같은 경우는 버퍼가 다 차기전까지 다른 작업을 수행할 수 있으므로 `논블로킹`이다.

# 3. 동기와비동기/ 블로킹과 논블로킹

위의 두 개념은 비슷하게 보이지만 다른 개념이다. 둘을 같이 살펴보자.

### 비동기+ 블로킹

만약에 내가 뭔가를 호출하고 결과를 다른 쓰레드가 처리한다. 이는 비동기이다. 그러면 다른 쓰레드가 작업을 처리하니까 나는 다른 쓰레드를 기다릴 필요가 없다 . 그래서 비동기이면서 블로킹 처리를 할 필요가없다. 왜냐하면 비동기자체가 내가 아니라 다른 쓰레드가 작업을 처리하는데 그 결과를 내가 기다릴 필요가 없으니 나랑은 상관없는 일인 것이다.

### 동기 + 블로킹

만약에 동기라면 즉, 내가 호출하고 내가 결과를 처리해야하고, 내가 작업을 처리할때 다른 작업이 수행되지 못하고 기다린다. 보통 파일 업로드에 사용할 수 있다. 사용자가 파일 선택후 업로드를 했을때 서버는 받은 파일을 받아서 저장하는 작업을 동기적으로 처리한다. 그리고 파일이 완전히 저장되기전까지 다른 작업이 수행되지 않는다. (= 블로킹) 그리고 서버는 파일 업로드가 완료되면 응답을 전송한다. (= 동기)