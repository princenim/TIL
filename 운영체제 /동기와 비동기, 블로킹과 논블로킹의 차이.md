# 📌 동기와 비동기 / 블로킹과 논블로킹의 차이

# 1. 동기와 비동기

`동기와` `비동기`의 차이는 내가 API 호출을 했을 때 이 그 “결과”를 누가 처리하느냐에 따라서 다르다. **만약에  내가 호출하고 내가 처리하면 `동기`,  내가 호출하고 결과를 다른 쓰레드가 처리하면 `비동기`다.** 그래서 대표적인 비동기의 예시가 메세지 큐에 메세지를 넣어넣고 나는 다른 일을 하는 것이다.

## 1.1 동기(Synchronous)

내가 호출하고 내가 처리하면 `동기(Synchronous)`이다. 예를 들어 작업 A를 호출하고 다른 쓰레드가 작업 A를 이어서 처리 , 그리고 내가 작업 A를 넘겨받아 결과를 처리하면 이 또한 동기이다. 이렇듯 동기 작업은 순차적으로 진행되며 쓰레드의 개수와는 상관없다.

동기 프로그래밍은 코드가 순차적으로 실행되므로 프로그램의 흐름을 이해가 쉬우나 하나의 작업이 끝날때까지 다른 작업을 처리하지 못하므로 전체 프로세스가 느려질 수 있다.

## 1.2 비동기 (Asynchronous)

내가 호출하고 다른 쓰레드가 처리하면 `비동기(Asynchronous)`이다. 따라서 내가 작업을 호출한 후에 다른 쓰레드가 작업을 처리하면 나는 다른 작업을 처리할 수 있다.

비동기 프로그래밍은 코드의 여러 작업을 동시에 처리할 수 있어 전체적인 성능이 향상된다. 하지만 코드의 복잡성이 증가한다.

### 비동기의 예시

유튜브를 업로드할때를 생각해보자. 동영상을 업로드하면 동영상은 업로드를 하고, 인코딩하는 과정을 거쳐야한다. 하지만 사용자는 업로드 버튼을 누르고 다른 작업을 할 수 있다. 이렇게 내가 동영상 업로드하는 API를 호출했지만 다른 쓰레드가 작업을 처리하는 것이 `비동기`이다. 더 자세히 알아보면

1. 메인 쓰레드에서 동영상을 업로드를 시작한다. 사용자는 업로드과 완료되지 않아도 다른 작업을 할 수 있다.
2. 업로드 작업을 처리하기 위한 별도의 쓰레드 1이 생성되고, 이 쓰레드에서 동영상 업로드 작업을 비동기적으로 수행한다.
3. 쓰레드 1이 동영상 업로드 작업을 완료하면 쓰레드 2가 동영상 인코딩 작업을 실행한다. 그리고 인코딩이 완료되면 사용자에게 알림을 보낸다.

똑같은 예시로 카카오톡에서 동영상을 다른 사람에게 보내도 메세지를 보낼 수 있는 것도 비동기작업이다.

# 2. 블로킹과 논블로킹

**블로킹은 어떤 작업이 실행되는동안 내가 다른 일을 못하면 블로킹이고, 다른 작업을 할 수 있으면 논블로킹이다.**

## 2.1 블로킹(blocking)

블로킹은 어떤 작업이 실행되는 동안 해당 작업이 완료될때까지 내가 다른 작업을 수행하지 못하는 상태를 의미한다. 즉 한 쓰레드가 작업을 수행할때 다른 쓰레드는 작업을 수행하지 못하고 대기하게 된다.

## 2.2 논블로킹(non-blocking)

논블로킹은 어떤 작업이 진행중이더라도 내가 다른 작업을 수행할 수 있는 상태를 의미한다. 한쓰레드에서 작업이 진행되어도 다른 쓰레드에서 작업을 수행할 수 있는 상태를 말한다.

# 3. 동기와비동기/ 블로킹과 논블로킹

위의 두 개념은 비슷하게 보이지만 다른 개념이다. 둘을 같이 살펴보자.

### 비동기+ 블로킹

만약에 내가 뭔가를 호출하고 결과를 다른 쓰레드가 처리한다. 이는 비동기이다. 그러면 다른 쓰레드가 작업을 처리하니까 나는 다른 쓰레드를 기다릴 필요가 없다 . 그래서 비동기이면서 블로킹 처리를 할 필요가없다. 왜냐하면 비동기자체가 내가 아니라 다른 쓰레드가 작업을 처리하는데 그 결과를 내가 기다릴 필요가 없으니 나랑은 상관없는 일인 것이다.

### 동기 + 블로킹

만약에 동기라면 즉, 내가 호출하고 내가 결과를 처리해야하고, 내가 작업을 처리할때 다른 작업이 수행되지 못하고 기다린다. 보통 파일 업로드에 사용할 수 있다. 사용자가 파일 선택후 업로드를 했을때 서버는 받은 파일을 받아서 저장하는 작업을 동기적으로 처리한다. 그리고 파일이 완전히 저장되기전까지 다른 작업이 수행되지 않는다. (= 블로킹) 그리고 서버는 파일 업로드가 완료되면 응답을 전송한다. (= 동기)

자바의 `Stream`이 일반적으로 동기이면서 블로킹이다. 데이터를 순차적으로 처리하며 입출력작업에서 데이터를 읽거나 쓸때 해당 작업이 완료될때까지 블로킹된다. 즉, 한번의 작업을 처리하고 작업이 완료될때까지 다음 작업을 진행하지 않는다.